[
  {
    "Query": "ALTER EXTENSION hstore UPDATE TO '2.0';"
  },
  {
    "Query": "ALTER EXTENSION hstore SET SCHEMA utils;"
  },
  {
    "Query": "ALTER EXTENSION hstore ADD FUNCTION populate_record(anyelement, hstore);"
  },
  {
    "Query": "CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$\nBEGIN\n    RETURN subtotal * 0.06;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION sales_tax(real) RETURNS real AS $$\nDECLARE\n    subtotal ALIAS FOR $1;\nBEGIN\n    RETURN subtotal * 0.06;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$\nDECLARE\n    v_string ALIAS FOR $1;\n    index ALIAS FOR $2;\nBEGIN\n    -- some computations using v_string and index here\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$\nBEGIN\n    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$\nBEGIN\n    tax := subtotal * 0.06;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$\nBEGIN\n    sum := x + y;\n    prod := x * y;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION extended_sales(p_itemno int)\nRETURNS TABLE(quantity int, total numeric) AS $$\nBEGIN\n    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales AS s\n                 WHERE s.itemno = p_itemno;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)\nRETURNS anyelement AS $$\nDECLARE\n    result ALIAS FOR $0;\nBEGIN\n    result := v1 + v2 + v3;\n    RETURN result;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,\n                                 OUT sum anyelement)\nAS $$\nBEGIN\n    sum := v1 + v2 + v3;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION add_three_values(v1 anycompatible, v2 anycompatible, v3 anycompatible)\nRETURNS anycompatible AS $$\nBEGIN\n    RETURN v1 + v2 + v3;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT add_three_values(1, 2, 4.7);"
  },
  {
    "Query": "CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$\nDECLARE\n    t2_row table2%ROWTYPE;\nBEGIN\n    SELECT * INTO t2_row FROM table2 WHERE ... ;\n    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\nBEGIN\n    RETURN a < b;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT less_than(text_field_1, text_field_2) FROM table1;"
  },
  {
    "Query": "SELECT less_than(text_field_1, text_field_2 COLLATE \"C\") FROM table1;"
  },
  {
    "Query": "CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$\nDECLARE\n    local_a text := a;\n    local_b text := b;\nBEGIN\n    RETURN local_a < local_b;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$\nBEGIN\n    RETURN a < b COLLATE \"C\";\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);"
  },
  {
    "Query": "CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);"
  },
  {
    "Query": "DROP OPERATOR FAMILY float_ops USING btree;"
  },
  {
    "Query": "DROP ROLE jonathan;"
  },
  {
    "Query": "DROP USER MAPPING IF EXISTS FOR bob SERVER foo;"
  },
  {
    "Query": "SET client_min_messages = DEBUG1;"
  },
  {
    "Query": "LOAD 'auto_explain';"
  },
  {
    "Query": "LOAD 'auto_explain';"
  },
  {
    "Query": "SET auto_explain.log_min_duration = 0;"
  },
  {
    "Query": "SET auto_explain.log_analyze = true;"
  },
  {
    "Query": "SELECT count(*)\n           FROM pg_class, pg_index\n           WHERE oid = indrelid AND indisunique;"
  },
  {
    "Query": "SELECT dblink_cancel_query('dtest1');"
  },
  {
    "Query": "ALTER SERVER foo OPTIONS (host 'foo', dbname 'foodb');"
  },
  {
    "Query": "ALTER SERVER foo VERSION '8.4' OPTIONS (SET host 'baz');"
  },
  {
    "Query": "DROP TEXT SEARCH TEMPLATE thesaurus;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (3);"
  },
  {
    "Query": "SAVEPOINT my_savepoint;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (4);"
  },
  {
    "Query": "RELEASE SAVEPOINT my_savepoint;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "SELECT dblink_get_connections();"
  },
  {
    "Query": "CREATE TABLE accounts (manager text, company text, contact_email text);"
  },
  {
    "Query": "ALTER TABLE accounts ENABLE ROW LEVEL SECURITY;"
  },
  {
    "Query": "CREATE POLICY account_managers ON accounts TO managers\n    USING (manager = current_user);"
  },
  {
    "Query": "CREATE POLICY user_policy ON users\n    USING (user_name = current_user);"
  },
  {
    "Query": "CREATE POLICY user_sel_policy ON users\n    FOR SELECT\n    USING (true);"
  },
  {
    "Query": "CREATE POLICY user_mod_policy ON users\n    USING (user_name = current_user);"
  },
  {
    "Query": "CREATE TABLE passwd (\n  user_name             text UNIQUE NOT NULL,\n  pwhash                text,\n  uid                   int  PRIMARY KEY,\n  gid                   int  NOT NULL,\n  real_name             text NOT NULL,\n  home_phone            text,\n  extra_info            text,\n  home_dir              text NOT NULL,\n  shell                 text NOT NULL\n);"
  },
  {
    "Query": "CREATE ROLE admin;"
  },
  {
    "Query": "CREATE ROLE bob;"
  },
  {
    "Query": "CREATE ROLE alice;"
  },
  {
    "Query": "INSERT INTO passwd VALUES\n  ('admin','xxx',0,0,'Admin','111-222-3333',null,'/root','/bin/dash');"
  },
  {
    "Query": "INSERT INTO passwd VALUES\n  ('bob','xxx',1,1,'Bob','123-456-7890',null,'/home/bob','/bin/zsh');"
  },
  {
    "Query": "INSERT INTO passwd VALUES\n  ('alice','xxx',2,1,'Alice','098-765-4321',null,'/home/alice','/bin/zsh');"
  },
  {
    "Query": "ALTER TABLE passwd ENABLE ROW LEVEL SECURITY;"
  },
  {
    "Query": "CREATE POLICY admin_all ON passwd TO admin USING (true) WITH CHECK (true);"
  },
  {
    "Query": "CREATE POLICY all_view ON passwd FOR SELECT USING (true);"
  },
  {
    "Query": "CREATE POLICY user_mod ON passwd FOR UPDATE\n  USING (current_user = user_name)\n  WITH CHECK (\n    current_user = user_name AND\n    shell IN ('/bin/bash','/bin/sh','/bin/dash','/bin/zsh','/bin/tcsh')\n  );"
  },
  {
    "Query": "GRANT SELECT, INSERT, UPDATE, DELETE ON passwd TO admin;"
  },
  {
    "Query": "GRANT SELECT\n  (user_name, uid, gid, real_name, home_phone, extra_info, home_dir, shell)\n  ON passwd TO public"
  },
  {
    "Query": "GRANT UPDATE\n  (pwhash, real_name, home_phone, extra_info, shell)\n  ON passwd TO public"
  },
  {
    "Query": "CREATE POLICY admin_local_only ON passwd AS RESTRICTIVE TO admin\n    USING (pg_catalog.inet_client_addr() IS NULL);"
  },
  {
    "Query": "SELECT current_user;"
  },
  {
    "Query": "SELECT current_user"
  },
  {
    "Query": "TABLE passwd"
  },
  {
    "Query": "UPDATE passwd set pwhash = NULL"
  },
  {
    "Query": "CREATE TABLE groups (group_id int PRIMARY KEY,\n                     group_name text NOT NULL);"
  },
  {
    "Query": "INSERT INTO groups VALUES\n  (1, 'low'),\n  (2, 'medium'),\n  (5, 'high');"
  },
  {
    "Query": "GRANT ALL ON groups TO alice;"
  },
  {
    "Query": "GRANT SELECT ON groups TO public;"
  },
  {
    "Query": "CREATE TABLE users (user_name text PRIMARY KEY,\n                    group_id int NOT NULL REFERENCES groups);"
  },
  {
    "Query": "INSERT INTO users VALUES\n  ('alice', 5),\n  ('bob', 2),\n  ('mallory', 2);"
  },
  {
    "Query": "GRANT ALL ON users TO alice;"
  },
  {
    "Query": "GRANT SELECT ON users TO public;"
  },
  {
    "Query": "CREATE TABLE information (info text,\n                          group_id int NOT NULL REFERENCES groups);"
  },
  {
    "Query": "INSERT INTO information VALUES\n  ('barely secret', 1),\n  ('slightly secret', 2),\n  ('very secret', 5);"
  },
  {
    "Query": "ALTER TABLE information ENABLE ROW LEVEL SECURITY;"
  },
  {
    "Query": "CREATE POLICY fp_s ON information FOR SELECT\n  USING (group_id <= (SELECT group_id FROM users WHERE user_name = current_user));"
  },
  {
    "Query": "CREATE POLICY fp_u ON information FOR UPDATE\n  USING (group_id <= (SELECT group_id FROM users WHERE user_name = current_user));"
  },
  {
    "Query": "GRANT ALL ON information TO public;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "UPDATE users SET group_id = 1 WHERE user_name = 'mallory';"
  },
  {
    "Query": "UPDATE information SET info = 'secret from mallory' WHERE group_id = 2;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "SELECT * FROM information WHERE group_id = 2 FOR UPDATE;"
  },
  {
    "Query": "CREATE DATABASE korean WITH ENCODING 'EUC_KR' LC_COLLATE='ko_KR.euckr' LC_CTYPE='ko_KR.euckr' TEMPLATE=template0;"
  },
  {
    "Query": "SET CLIENT_ENCODING TO 'value';"
  },
  {
    "Query": "SET NAMES 'value';"
  },
  {
    "Query": "SHOW client_encoding;"
  },
  {
    "Query": "RESET client_encoding;"
  },
  {
    "Query": "CREATE FUNCTION test_event_trigger_for_drops()\n        RETURNS event_trigger LANGUAGE plpgsql AS $$\nDECLARE\n    obj record;\nBEGIN\n    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n    LOOP\n        RAISE NOTICE '% dropped object: % %.% %',\n                     tg_tag,\n                     obj.object_type,\n                     obj.schema_name,\n                     obj.object_name,\n                     obj.object_identity;\n    END LOOP;\nEND;\n$$;"
  },
  {
    "Query": "CREATE EVENT TRIGGER test_event_trigger_for_drops\n   ON sql_drop\n   EXECUTE FUNCTION test_event_trigger_for_drops();"
  },
  {
    "Query": "CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n RETURNS event_trigger\n LANGUAGE plpgsql AS\n$$\nBEGIN\n  RAISE NOTICE 'rewriting table % for reason %',\n                pg_event_trigger_table_rewrite_oid()::regclass,\n                pg_event_trigger_table_rewrite_reason();\nEND;\n$$;"
  },
  {
    "Query": "CREATE EVENT TRIGGER test_table_rewrite_oid\n                  ON table_rewrite\n   EXECUTE FUNCTION test_event_trigger_table_rewrite_oid();"
  },
  {
    "Query": "ALTER DATABASE test SET enable_indexscan TO off;"
  },
  {
    "Query": "CREATE TABLE t (a INT, b INT);"
  },
  {
    "Query": "INSERT INTO t SELECT i % 100, i % 100 FROM generate_series(1, 10000) s(i);"
  },
  {
    "Query": "ANALYZE t;"
  },
  {
    "Query": "SELECT relpages, reltuples FROM pg_class WHERE relname = 't';"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;"
  },
  {
    "Query": "CREATE STATISTICS stts (dependencies) ON a, b FROM t;"
  },
  {
    "Query": "ANALYZE t;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;"
  },
  {
    "Query": "DROP STATISTICS stts;"
  },
  {
    "Query": "CREATE STATISTICS stts (dependencies, ndistinct) ON a, b FROM t;"
  },
  {
    "Query": "ANALYZE t;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT COUNT(*) FROM t GROUP BY a, b;"
  },
  {
    "Query": "DROP STATISTICS stts;"
  },
  {
    "Query": "CREATE STATISTICS stts2 (mcv) ON a, b FROM t;"
  },
  {
    "Query": "ANALYZE t;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 1;"
  },
  {
    "Query": "SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),\n                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts2';"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a = 1 AND b = 10;"
  },
  {
    "Query": "EXPLAIN (ANALYZE, TIMING OFF) SELECT * FROM t WHERE a <= 49 AND b > 49;"
  },
  {
    "Query": "CREATE TYPE complex;"
  },
  {
    "Query": "CREATE FUNCTION complex_in(cstring)\n    RETURNS complex\n    AS 'filename'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE FUNCTION complex_out(complex)\n    RETURNS cstring\n    AS 'filename'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE FUNCTION complex_recv(internal)\n   RETURNS complex\n   AS 'filename'\n   LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE FUNCTION complex_send(complex)\n   RETURNS bytea\n   AS 'filename'\n   LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE TYPE complex (\n   internallength = 16,\n   input = complex_in,\n   output = complex_out,\n   receive = complex_recv,\n   send = complex_send,\n   alignment = double\n);"
  },
  {
    "Query": "CREATE EXTENSION tsm_system_rows;"
  },
  {
    "Query": "SELECT * FROM my_table TABLESAMPLE SYSTEM_ROWS(100);"
  },
  {
    "Query": "CREATE EXTENSION file_fdw;"
  },
  {
    "Query": "CREATE SERVER pglog FOREIGN DATA WRAPPER file_fdw;"
  },
  {
    "Query": "CREATE FOREIGN TABLE pglog (\n  log_time timestamp(3) with time zone,\n  user_name text,\n  database_name text,\n  process_id integer,\n  connection_from text,\n  session_id text,\n  session_line_num bigint,\n  command_tag text,\n  session_start_time timestamp with time zone,\n  virtual_transaction_id text,\n  transaction_id bigint,\n  error_severity text,\n  sql_state_code text,\n  message text,\n  detail text,\n  hint text,\n  internal_query text,\n  internal_query_pos integer,\n  context text,\n  query text,\n  query_pos integer,\n  location text,\n  application_name text,\n  backend_type text\n) SERVER pglog\nOPTIONS ( filename 'log/pglog.csv', format 'csv' );"
  },
  {
    "Query": "SELECT * FROM accounts AS a, pgrowlocks('accounts') AS p\n  WHERE p.locked_row = a.ctid;"
  },
  {
    "Query": "UPDATE weather\n    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2\n    WHERE date > '1994-11-28';"
  },
  {
    "Query": "SELECT * FROM weather;"
  },
  {
    "Query": "SELECT * FROM test1 WHERE lower(col1) = 'value';"
  },
  {
    "Query": "CREATE INDEX test1_lower_col1_idx ON test1 (lower(col1));"
  },
  {
    "Query": "SELECT * FROM people WHERE (first_name || ' ' || last_name) = 'John Smith';"
  },
  {
    "Query": "CREATE INDEX people_names ON people ((first_name || ' ' || last_name));"
  },
  {
    "Query": "CREATE TABLE phone_data (person text, phone text, private boolean);"
  },
  {
    "Query": "CREATE VIEW phone_number AS\n    SELECT person, CASE WHEN NOT private THEN phone END AS phone\n    FROM phone_data;"
  },
  {
    "Query": "GRANT SELECT ON phone_number TO assistant;"
  },
  {
    "Query": "CREATE VIEW phone_number AS\n    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';"
  },
  {
    "Query": "CREATE FUNCTION tricky(text, text) RETURNS bool AS $$\nBEGIN\n    RAISE NOTICE '% => %', $1, $2;\n    RETURN true;\nEND;\n$$ LANGUAGE plpgsql COST 0.0000000000000000000001;"
  },
  {
    "Query": "SELECT * FROM phone_number WHERE tricky(person, phone);"
  },
  {
    "Query": "CREATE VIEW phone_number WITH (security_barrier) AS\n    SELECT person, phone FROM phone_data WHERE phone NOT LIKE '412%';"
  },
  {
    "Query": "ROLLBACK;"
  },
  {
    "Query": "CREATE EXTENSION tsm_system_time;"
  },
  {
    "Query": "SELECT * FROM my_table TABLESAMPLE SYSTEM_TIME(1000);"
  },
  {
    "Query": "CREATE TABLE test1c (\n    id integer,\n    content varchar COLLATE \"x\"\n);"
  },
  {
    "Query": "CREATE INDEX test1c_content_index ON test1c (content);"
  },
  {
    "Query": "SELECT * FROM test1c WHERE content > constant;"
  },
  {
    "Query": "SELECT * FROM test1c WHERE content > constant COLLATE \"y\";"
  },
  {
    "Query": "CREATE INDEX test1c_content_y_index ON test1c (content COLLATE \"y\");"
  },
  {
    "Query": "DROP SCHEMA mystuff CASCADE;"
  },
  {
    "Query": "CREATE VIEW vista AS SELECT 'Hello World';"
  },
  {
    "Query": "CREATE VIEW vista AS SELECT text 'Hello World' AS hello;"
  },
  {
    "Query": "CREATE VIEW comedies AS\n    SELECT *\n    FROM films\n    WHERE kind = 'Comedy';"
  },
  {
    "Query": "CREATE VIEW universal_comedies AS\n    SELECT *\n    FROM comedies\n    WHERE classification = 'U'\n    WITH LOCAL CHECK OPTION;"
  },
  {
    "Query": "CREATE VIEW pg_comedies AS\n    SELECT *\n    FROM comedies\n    WHERE classification = 'PG'\n    WITH CASCADED CHECK OPTION;"
  },
  {
    "Query": "CREATE VIEW comedies AS\n    SELECT f.*,\n           country_code_to_name(f.country_code) AS country,\n           (SELECT avg(r.rating)\n            FROM user_ratings r\n            WHERE r.film_id = f.id) AS avg_rating\n    FROM films f\n    WHERE f.kind = 'Comedy';"
  },
  {
    "Query": "CREATE RECURSIVE VIEW public.nums_1_100 (n) AS\n    VALUES (1)\nUNION ALL\n    SELECT n+1 FROM nums_1_100 WHERE n < 100;"
  },
  {
    "Query": "CREATE TYPE compfoo AS (f1 int, f2 text);"
  },
  {
    "Query": "CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$\n    SELECT fooid, fooname FROM foo\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');"
  },
  {
    "Query": "CREATE TABLE bug (\n    id serial,\n    description text,\n    status bug_status\n);"
  },
  {
    "Query": "CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);"
  },
  {
    "Query": "CREATE TYPE box;"
  },
  {
    "Query": "CREATE TYPE box (\n    INTERNALLENGTH = 16,\n    INPUT = my_box_in_function,\n    OUTPUT = my_box_out_function\n);"
  },
  {
    "Query": "CREATE TABLE myboxes (\n    id integer,\n    description box\n);"
  },
  {
    "Query": "CREATE TYPE box (\n    INTERNALLENGTH = 16,\n    INPUT = my_box_in_function,\n    OUTPUT = my_box_out_function,\n    ELEMENT = float4\n);"
  },
  {
    "Query": "CREATE TYPE bigobj (\n    INPUT = lo_filein, OUTPUT = lo_fileout,\n    INTERNALLENGTH = VARIABLE\n);"
  },
  {
    "Query": "CREATE TABLE big_objs (\n    id integer,\n    obj bigobj\n);"
  },
  {
    "Query": "SELECT *\n    FROM dblink('dbname=mydb options=-csearch_path=',\n                'select proname, prosrc from pg_proc')\n      AS t1(proname name, prosrc text)\n    WHERE proname LIKE 'bytea%';"
  },
  {
    "Query": "CREATE VIEW myremote_pg_proc AS\n  SELECT *\n    FROM dblink('dbname=postgres options=-csearch_path=',\n                'select proname, prosrc from pg_proc')\n    AS t1(proname name, prosrc text);"
  },
  {
    "Query": "SELECT * FROM myremote_pg_proc WHERE proname LIKE 'bytea%';"
  },
  {
    "Query": "CREATE COLLATION french (locale = 'fr_FR.utf8');"
  },
  {
    "Query": "CREATE COLLATION german_phonebook (provider = icu, locale = 'de-u-co-phonebk');"
  },
  {
    "Query": "CREATE COLLATION german FROM \"de_DE\";"
  },
  {
    "Query": "SELECT extract(julian from '2021-06-23 7:00:00-04'::timestamptz at time zone 'UTC+12');"
  },
  {
    "Query": "SELECT extract(julian from '2021-06-23 8:00:00-04'::timestamptz at time zone 'UTC+12')"
  },
  {
    "Query": "SELECT extract(julian from date '2021-06-23')"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "INSERT INTO products VALUES (1, 'Cheese', 9.99);"
  },
  {
    "Query": "INSERT INTO products (product_no, name, price) VALUES (1, 'Cheese', 9.99);"
  },
  {
    "Query": "INSERT INTO products (name, price, product_no) VALUES ('Cheese', 9.99, 1);"
  },
  {
    "Query": "INSERT INTO products (product_no, name) VALUES (1, 'Cheese');"
  },
  {
    "Query": "INSERT INTO products VALUES (1, 'Cheese');"
  },
  {
    "Query": "INSERT INTO products (product_no, name, price) VALUES (1, 'Cheese', DEFAULT);"
  },
  {
    "Query": "INSERT INTO products DEFAULT VALUES;"
  },
  {
    "Query": "INSERT INTO products (product_no, name, price) VALUES\n    (1, 'Cheese', 9.99),\n    (2, 'Bread', 1.99),\n    (3, 'Milk', 2.99);"
  },
  {
    "Query": "INSERT INTO products (product_no, name, price)\n  SELECT product_no, name, price FROM new_products\n    WHERE release_date = 'today';"
  },
  {
    "Query": "CREATE TABLE cities (\n        name     varchar(80) primary key,\n        location point\n);"
  },
  {
    "Query": "CREATE TABLE weather (\n        city      varchar(80) references cities(name),\n        temp_lo   int,\n        temp_hi   int,\n        prcp      real,\n        date      date\n);"
  },
  {
    "Query": "INSERT INTO weather VALUES ('Berkeley', 45, 53, 0.0, '1994-11-28');"
  },
  {
    "Query": "DROP VIEW kinds;"
  },
  {
    "Query": "SELECT has_table_privilege('myschema.mytable', 'select');"
  },
  {
    "Query": "SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');"
  },
  {
    "Query": "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"
  },
  {
    "Query": "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"
  },
  {
    "Query": "SELECT pg_type_is_visible('myschema.widget'::regtype);"
  },
  {
    "Query": "SELECT currval(pg_get_serial_sequence('sometable', 'id'));"
  },
  {
    "Query": "SELECT pg_typeof(33);"
  },
  {
    "Query": "SELECT typlen FROM pg_type WHERE oid = pg_typeof(33)"
  },
  {
    "Query": "SELECT collation for (description) FROM pg_description LIMIT 1;"
  },
  {
    "Query": "SELECT collation for ('foo' COLLATE \"de_DE\")"
  },
  {
    "Query": "CREATE FUNCTION usesavedplan() RETURNS trigger AS $$\n    if \"plan\" in SD:\n        plan = SD[\"plan\"]\n    else:\n        plan = plpy.prepare(\"SELECT 1\")\n        SD[\"plan\"] = plan\n    # rest of function\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION count_odd_iterator() RETURNS integer AS $$\nodd = 0\nfor row in plpy.cursor(\"select num from largetable\"):\n    if row['num'] % 2:\n         odd += 1\nreturn odd\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION count_odd_fetch(batch_size integer) RETURNS integer AS $$\nodd = 0\ncursor = plpy.cursor(\"select num from largetable\")\nwhile True:\n    rows = cursor.fetch(batch_size)\n    if not rows:\n        break\n    for row in rows:\n        if row['num'] % 2:\n            odd += 1\nreturn odd\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION count_odd_prepared() RETURNS integer AS $$\nodd = 0\nplan = plpy.prepare(\"select num from largetable where num % $1 <> 0\", [\"integer\"])\nrows = list(plpy.cursor(plan, [2]))  # or: = list(plan.cursor([2]))\n\nreturn len(rows)\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION try_adding_joe() RETURNS text AS $$\n    try:\n        plpy.execute(\"INSERT INTO users(username) VALUES ('joe')\")\n    except plpy.SPIError:\n        return \"something went wrong\"\n    else:\n        return \"Joe added\"\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION insert_fraction(numerator int, denominator int) RETURNS text AS $$\nfrom plpy import spiexceptions\ntry:\n    plan = plpy.prepare(\"INSERT INTO fractions (frac) VALUES ($1 / $2)\", [\"int\", \"int\"])\n    plpy.execute(plan, [numerator, denominator])\nexcept spiexceptions.DivisionByZero:\n    return \"denominator cannot equal zero\"\nexcept spiexceptions.UniqueViolation:\n    return \"already have that fraction\"\nexcept plpy.SPIError as e:\n    return \"other error, SQLSTATE %s\" % e.sqlstate\nelse:\n    return \"fraction inserted\"\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "INSERT INTO a SELECT * FROM a;"
  },
  {
    "Query": "SELECT to_hex(trunc(EXTRACT(EPOCH FROM backend_start))::integer) || '.' ||\n       to_hex(pid)\nFROM pg_stat_activity;"
  },
  {
    "Query": "CREATE TABLE postgres_log\n(\n  log_time timestamp(3) with time zone,\n  user_name text,\n  database_name text,\n  process_id integer,\n  connection_from text,\n  session_id text,\n  session_line_num bigint,\n  command_tag text,\n  session_start_time timestamp with time zone,\n  virtual_transaction_id text,\n  transaction_id bigint,\n  error_severity text,\n  sql_state_code text,\n  message text,\n  detail text,\n  hint text,\n  internal_query text,\n  internal_query_pos integer,\n  context text,\n  query text,\n  query_pos integer,\n  location text,\n  application_name text,\n  backend_type text,\n  PRIMARY KEY (session_id, session_line_num)\n);"
  },
  {
    "Query": "COPY postgres_log FROM '/full/path/to/logfile.csv' WITH csv;"
  },
  {
    "Query": "CREATE TABLESPACE dbspace LOCATION '/data/dbs';"
  },
  {
    "Query": "CREATE TABLESPACE indexspace OWNER genevieve LOCATION '/data/indexes';"
  },
  {
    "Query": "DROP PUBLICATION mypublication;"
  },
  {
    "Query": "CREATE TABLE t1 (\n    a   int,\n    b   int\n);"
  },
  {
    "Query": "INSERT INTO t1 SELECT i/100, i/500\n                 FROM generate_series(1,1000000) s(i);"
  },
  {
    "Query": "ANALYZE t1;"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM t1 WHERE (a = 1) AND (b = 0);"
  },
  {
    "Query": "CREATE STATISTICS s1 (dependencies) ON a, b FROM t1;"
  },
  {
    "Query": "ANALYZE t1;"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM t1 WHERE (a = 1) AND (b = 0);"
  },
  {
    "Query": "CREATE TABLE t2 (\n    a   int,\n    b   int\n);"
  },
  {
    "Query": "INSERT INTO t2 SELECT mod(i,100), mod(i,100)\n                 FROM generate_series(1,1000000) s(i);"
  },
  {
    "Query": "CREATE STATISTICS s2 (mcv) ON a, b FROM t2;"
  },
  {
    "Query": "ANALYZE t2;"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM t2 WHERE (a = 1) AND (b = 1);"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM t2 WHERE (a = 1) AND (b = 2);"
  },
  {
    "Query": "CREATE PUBLICATION mypublication FOR TABLE users, departments;"
  },
  {
    "Query": "CREATE PUBLICATION alltables FOR ALL TABLES;"
  },
  {
    "Query": "CREATE PUBLICATION insert_only FOR TABLE mydata\n    WITH (publish = 'insert');"
  },
  {
    "Query": "CREATE FUNCTION raise_custom_exception() RETURNS void AS $$\nplpy.error(\"custom exception message\",\n           detail=\"some info about exception\",\n           hint=\"hint for users\")\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "SELECT raise_custom_exception();"
  },
  {
    "Query": "CREATE PROCEDURE transaction_test1()\nLANGUAGE pltcl\nAS $$\nfor {set i 0} {$i < 10} {incr i} {\n    spi_exec \"INSERT INTO test1 (a) VALUES ($i)\"\n    if {$i % 2 == 0} {\n        commit\n    } else {\n        rollback\n    }\n}\n$$;"
  },
  {
    "Query": "CALL transaction_test1();"
  },
  {
    "Query": "DROP STATISTICS IF EXISTS\n    accounting.users_uid_creation,\n    public.grants_user_role;"
  },
  {
    "Query": "CREATE FUNCTION concat_lower_or_upper(a text, b text, uppercase boolean DEFAULT false)\nRETURNS text\nAS\n$$\n SELECT CASE\n        WHEN $3 THEN UPPER($1 || ' ' || $2)\n        ELSE LOWER($1 || ' ' || $2)\n        END;\n$$\nLANGUAGE SQL IMMUTABLE STRICT;"
  },
  {
    "Query": "SELECT '\\xDEADBEEF';"
  },
  {
    "Query": "SET bytea_output = 'escape';"
  },
  {
    "Query": "SELECT 'abc \\153\\154\\155 \\052\\251\\124'::bytea;"
  },
  {
    "Query": "CREATE VIEW myview AS SELECT * FROM mytab;"
  },
  {
    "Query": "CREATE RULE \"_RETURN\" AS ON SELECT TO myview DO INSTEAD\n    SELECT * FROM mytab;"
  },
  {
    "Query": "CREATE TABLE shoe_data (\n    shoename   text,\nsh_avail   integer,\nslcolor    text,\nslminlen   real,\nslmaxlen   real,\nslunit     text\n);"
  },
  {
    "Query": "CREATE TABLE shoelace_data (\n    sl_name    text,\nsl_avail   integer,\nsl_color   text,\nsl_len     real,\nsl_unit    text\n);"
  },
  {
    "Query": "CREATE TABLE unit (\n    un_name    text,\nun_fact    real\n);"
  },
  {
    "Query": "CREATE VIEW shoe AS\n    SELECT sh.shoename,\n           sh.sh_avail,\n           sh.slcolor,\n           sh.slminlen,\n           sh.slminlen * un.un_fact AS slminlen_cm,\n           sh.slmaxlen,\n           sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n           sh.slunit\n      FROM shoe_data sh, unit un\n     WHERE sh.slunit = un.un_name;"
  },
  {
    "Query": "CREATE VIEW shoelace AS\n    SELECT s.sl_name,\n           s.sl_avail,\n           s.sl_color,\n           s.sl_len,\n           s.sl_unit,\n           s.sl_len * u.un_fact AS sl_len_cm\n      FROM shoelace_data s, unit u\n     WHERE s.sl_unit = u.un_name;"
  },
  {
    "Query": "CREATE VIEW shoe_ready AS\n    SELECT rsh.shoename,\n           rsh.sh_avail,\n           rsl.sl_name,\n           rsl.sl_avail,\n           least(rsh.sh_avail, rsl.sl_avail) AS total_avail\n      FROM shoe rsh, shoelace rsl\n     WHERE rsl.sl_color = rsh.slcolor\n       AND rsl.sl_len_cm >= rsh.slminlen_cm\n       AND rsl.sl_len_cm <= rsh.slmaxlen_cm;"
  },
  {
    "Query": "INSERT INTO unit VALUES ('cm', 1.0);"
  },
  {
    "Query": "INSERT INTO unit VALUES ('m', 100.0);"
  },
  {
    "Query": "INSERT INTO unit VALUES ('inch', 2.54);"
  },
  {
    "Query": "INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');"
  },
  {
    "Query": "INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');"
  },
  {
    "Query": "INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');"
  },
  {
    "Query": "INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');"
  },
  {
    "Query": "INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');"
  },
  {
    "Query": "SELECT * FROM shoelace;"
  },
  {
    "Query": "SELECT shoelace.sl_name, shoelace.sl_avail,\n       shoelace.sl_color, shoelace.sl_len,\n       shoelace.sl_unit, shoelace.sl_len_cm\n  FROM shoelace shoelace;"
  },
  {
    "Query": "SELECT s.sl_name, s.sl_avail,\n       s.sl_color, s.sl_len, s.sl_unit,\n       s.sl_len * u.un_fact AS sl_len_cm\n  FROM shoelace old, shoelace new,\n       shoelace_data s, unit u\n WHERE s.sl_unit = u.un_name;"
  },
  {
    "Query": "SELECT shoelace.sl_name, shoelace.sl_avail,\n       shoelace.sl_color, shoelace.sl_len,\n       shoelace.sl_unit, shoelace.sl_len_cm\n  FROM (SELECT s.sl_name,\n               s.sl_avail,\n               s.sl_color,\n               s.sl_len,\n               s.sl_unit,\n               s.sl_len * u.un_fact AS sl_len_cm\n          FROM shoelace_data s, unit u\n         WHERE s.sl_unit = u.un_name) shoelace;"
  },
  {
    "Query": "SELECT * FROM shoe_ready WHERE total_avail >= 2;"
  },
  {
    "Query": "SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n       shoe_ready.sl_name, shoe_ready.sl_avail,\n       shoe_ready.total_avail\n  FROM shoe_ready shoe_ready\n WHERE shoe_ready.total_avail >= 2;"
  },
  {
    "Query": "SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n       shoe_ready.sl_name, shoe_ready.sl_avail,\n       shoe_ready.total_avail\n  FROM (SELECT rsh.shoename,\n               rsh.sh_avail,\n               rsl.sl_name,\n               rsl.sl_avail,\n               least(rsh.sh_avail, rsl.sl_avail) AS total_avail\n          FROM shoe rsh, shoelace rsl\n         WHERE rsl.sl_color = rsh.slcolor\n           AND rsl.sl_len_cm >= rsh.slminlen_cm\n           AND rsl.sl_len_cm <= rsh.slmaxlen_cm) shoe_ready\n WHERE shoe_ready.total_avail >= 2;"
  },
  {
    "Query": "SELECT shoe_ready.shoename, shoe_ready.sh_avail,\n       shoe_ready.sl_name, shoe_ready.sl_avail,\n       shoe_ready.total_avail\n  FROM (SELECT rsh.shoename,\n               rsh.sh_avail,\n               rsl.sl_name,\n               rsl.sl_avail,\n               least(rsh.sh_avail, rsl.sl_avail) AS total_avail\n          FROM (SELECT sh.shoename,\n                       sh.sh_avail,\n                       sh.slcolor,\n                       sh.slminlen,\n                       sh.slminlen * un.un_fact AS slminlen_cm,\n                       sh.slmaxlen,\n                       sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n                       sh.slunit\n                  FROM shoe_data sh, unit un\n                 WHERE sh.slunit = un.un_name) rsh,\n               (SELECT s.sl_name,\n                       s.sl_avail,\n                       s.sl_color,\n                       s.sl_len,\n                       s.sl_unit,\n                       s.sl_len * u.un_fact AS sl_len_cm\n                  FROM shoelace_data s, unit u\n                 WHERE s.sl_unit = u.un_name) rsl\n         WHERE rsl.sl_color = rsh.slcolor\n           AND rsl.sl_len_cm >= rsh.slminlen_cm\n           AND rsl.sl_len_cm <= rsh.slmaxlen_cm) shoe_ready\n WHERE shoe_ready.total_avail > 2;"
  },
  {
    "Query": "SELECT t2.b FROM t1, t2 WHERE t1.a = t2.a;"
  },
  {
    "Query": "UPDATE t1 SET b = t2.b FROM t2 WHERE t1.a = t2.a;"
  },
  {
    "Query": "UPDATE t1 SET a = t1.a, b = t2.b FROM t2 WHERE t1.a = t2.a;"
  },
  {
    "Query": "SELECT t1.a, t2.b FROM t1, t2 WHERE t1.a = t2.a;"
  },
  {
    "Query": "SELECT t1.a, t2.b, t1.ctid FROM t1, t2 WHERE t1.a = t2.a;"
  },
  {
    "Query": "SELECT * FROM table1;"
  },
  {
    "Query": "SELECT a, b + c FROM table1;"
  },
  {
    "Query": "SELECT 3 * 4;"
  },
  {
    "Query": "SELECT random();"
  },
  {
    "Query": "DROP TRIGGER if_dist_exists ON films;"
  },
  {
    "Query": "CREATE FUNCTION badfunc() RETURNS integer AS $$\n    my $tmpfile = \"/tmp/badfile\";\n    open my $fh, '>', $tmpfile\n        or elog(ERROR, qq{could not open the file \"$tmpfile\": $!});\n    print $fh \"Testing writing to a file\\n\";\n    close $fh or elog(ERROR, qq{could not close the file \"$tmpfile\": $!});\n    return 1;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE DATABASE foo WITH TEMPLATE template0;"
  },
  {
    "Query": "CLOSE liahona;"
  },
  {
    "Query": "CREATE TABLE test2 (\n  major int,\n  minor int,\n  name varchar\n);"
  },
  {
    "Query": "SELECT name FROM test2 WHERE major = constant AND minor = constant;"
  },
  {
    "Query": "CREATE INDEX test2_mm_idx ON test2 (major, minor);"
  },
  {
    "Query": "DROP CONVERSION myname;"
  },
  {
    "Query": "DROP FOREIGN TABLE films, distributors;"
  },
  {
    "Query": "SELECT ts_lexize('xsyn', 'word');"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION english\n    ALTER MAPPING FOR word, asciiword WITH xsyn, english_stem;"
  },
  {
    "Query": "ALTER MATERIALIZED VIEW foo RENAME TO bar;"
  },
  {
    "Query": "ALTER DATABASE mydb SET geqo TO off;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION abort_any_command()\n  RETURNS event_trigger\n LANGUAGE plpgsql\n  AS $$\nBEGIN\n  RAISE EXCEPTION 'command % is disabled', tg_tag;\nEND;\n$$;"
  },
  {
    "Query": "CREATE EVENT TRIGGER abort_ddl ON ddl_command_start\n   EXECUTE FUNCTION abort_any_command();"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION no_rewrite()\n RETURNS event_trigger\n LANGUAGE plpgsql AS\n$$\n---\n--- Implement local Table Rewriting policy:\n---   public.foo is not allowed rewriting, ever\n---   other tables are only allowed rewriting between 1am and 6am\n---   unless they have more than 100 blocks\n---\nDECLARE\n  table_oid oid := pg_event_trigger_table_rewrite_oid();\n  current_hour integer := extract('hour' from current_time);\n  pages integer;\n  max_pages integer := 100;\nBEGIN\n  IF pg_event_trigger_table_rewrite_oid() = 'public.foo'::regclass\n  THEN\n        RAISE EXCEPTION 'you''re not allowed to rewrite the table %',\n                        table_oid::regclass;\n  END IF;\n\n  SELECT INTO pages relpages FROM pg_class WHERE oid = table_oid;\n  IF pages > max_pages\n  THEN\n        RAISE EXCEPTION 'rewrites only allowed for table with less than % pages',\n                        max_pages;\n  END IF;\n\n  IF current_hour NOT BETWEEN 1 AND 6\n  THEN\n        RAISE EXCEPTION 'rewrites only allowed between 1am and 6am';\n  END IF;\nEND;\n$$;"
  },
  {
    "Query": "CREATE EVENT TRIGGER no_rewrite_allowed\n                  ON table_rewrite\n   EXECUTE FUNCTION no_rewrite();"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1;"
  },
  {
    "Query": "SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 1000;"
  },
  {
    "Query": "SELECT histogram_bounds FROM pg_stats\nWHERE tablename='tenk1' AND attname='unique1';"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'CRAAAA';"
  },
  {
    "Query": "SELECT null_frac, n_distinct, most_common_vals, most_common_freqs FROM pg_stats\nWHERE tablename='tenk1' AND attname='stringu1';"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1 WHERE stringu1 = 'xxx';"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1 WHERE stringu1 < 'IAAAAA';"
  },
  {
    "Query": "SELECT histogram_bounds FROM pg_stats\nWHERE tablename='tenk1' AND attname='stringu1';"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1 WHERE unique1 < 1000 AND stringu1 = 'xxx';"
  },
  {
    "Query": "EXPLAIN SELECT * FROM tenk1 t1, tenk2 t2\nWHERE t1.unique1 < 50 AND t1.unique2 = t2.unique2"
  },
  {
    "Query": "SELECT tablename, null_frac,n_distinct, most_common_vals FROM pg_stats\nWHERE tablename IN ('tenk1', 'tenk2') AND attname='unique2';"
  },
  {
    "Query": "SELECT round(sum(OLDVALUE / n::float)) AS newvalue FROM generate_series(1, OLDVALUE) s(n);"
  },
  {
    "Query": "CREATE INDEX path_gist_idx ON test USING GIST (path);"
  },
  {
    "Query": "CREATE INDEX path_gist_idx ON test USING GIST (path gist_ltree_ops(siglen=100));"
  },
  {
    "Query": "CREATE INDEX path_gist_idx ON test USING GIST (array_path);"
  },
  {
    "Query": "CREATE INDEX path_gist_idx ON test USING GIST (array_path gist__ltree_ops(siglen=100));"
  },
  {
    "Query": "CREATE TABLE test (path ltree);"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Science');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Science.Astronomy');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Science.Astronomy.Astrophysics');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Science.Astronomy.Cosmology');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Hobbies');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Hobbies.Amateurs_Astronomy');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Collections');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Collections.Pictures');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Stars');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Galaxies');"
  },
  {
    "Query": "INSERT INTO test VALUES ('Top.Collections.Pictures.Astronomy.Astronauts');"
  },
  {
    "Query": "CREATE INDEX path_gist_idx ON test USING GIST (path);"
  },
  {
    "Query": "CREATE INDEX path_idx ON test USING BTREE (path);"
  },
  {
    "Query": "VALUES (1, 'one'), (2, 'two'), (3, 'three');"
  },
  {
    "Query": "SELECT 1 AS column1, 'one' AS column2\nUNION ALL\nSELECT 2, 'two'\nUNION ALL\nSELECT 3, 'three';"
  },
  {
    "Query": "INSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');"
  },
  {
    "Query": "INSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes'),\n    ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama', DEFAULT);"
  },
  {
    "Query": "SELECT f.*\n  FROM films f, (VALUES('MGM', 'Horror'), ('UA', 'Sci-Fi')) AS t (studio, kind)\n  WHERE f.studio = t.studio AND f.kind = t.kind;"
  },
  {
    "Query": "UPDATE employees SET salary = salary * v.increase\n  FROM (VALUES(1, 200000, 1.2), (2, 400000, 1.4)) AS v (depno, target, increase)\n  WHERE employees.depno = v.depno AND employees.sales >= v.target;"
  },
  {
    "Query": "SELECT * FROM machines\nWHERE ip_address IN (VALUES('192.168.0.1'::inet), ('192.168.0.10'), ('192.168.1.43'));"
  },
  {
    "Query": "ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT SELECT ON TABLES TO PUBLIC;"
  },
  {
    "Query": "ALTER DEFAULT PRIVILEGES IN SCHEMA myschema GRANT INSERT ON TABLES TO webuser;"
  },
  {
    "Query": "ALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE SELECT ON TABLES FROM PUBLIC;"
  },
  {
    "Query": "ALTER DEFAULT PRIVILEGES IN SCHEMA myschema REVOKE INSERT ON TABLES FROM webuser;"
  },
  {
    "Query": "ALTER DEFAULT PRIVILEGES FOR ROLE admin REVOKE EXECUTE ON FUNCTIONS FROM PUBLIC;"
  },
  {
    "Query": "ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE EXECUTE ON FUNCTIONS FROM PUBLIC;"
  },
  {
    "Query": "SECURITY LABEL FOR selinux ON TABLE mytable IS 'system_u:object_r:sepgsql_table_t:s0';"
  },
  {
    "Query": "CREATE TABLE test (a BIT(3), b BIT VARYING(5));"
  },
  {
    "Query": "INSERT INTO test VALUES (B'101', B'00');"
  },
  {
    "Query": "INSERT INTO test VALUES (B'10', B'101');"
  },
  {
    "Query": "INSERT INTO test VALUES (B'10'::bit(3), B'101')"
  },
  {
    "Query": "SELECT * FROM test;"
  },
  {
    "Query": "SELECT * FROM MY_TABLE;"
  },
  {
    "Query": "UPDATE MY_TABLE SET A = 5;"
  },
  {
    "Query": "INSERT INTO MY_TABLE VALUES (3, 'hi there');"
  },
  {
    "Query": "UPDATE MY_TABLE SET A = 5;"
  },
  {
    "Query": "uPDaTE my_TabLE SeT a = 5;"
  },
  {
    "Query": "UPDATE my_table SET a = 5;"
  },
  {
    "Query": "UPDATE \"my_table\" SET \"a\" = 5;"
  },
  {
    "Query": "SELECT 'foo'\n'bar';"
  },
  {
    "Query": "SELECT 'foobar';"
  },
  {
    "Query": "END"
  },
  {
    "Query": "SELECT 3 OPERATOR(pg_catalog.+) 4;"
  },
  {
    "Query": "ALTER ROUTINE foo(integer) RENAME TO foobar;"
  },
  {
    "Query": "COMMIT PREPARED 'foobar';"
  },
  {
    "Query": "DROP ACCESS METHOD heptree;"
  },
  {
    "Query": "CREATE USER MAPPING FOR bob SERVER foo OPTIONS (user 'bob', password 'secret');"
  },
  {
    "Query": "INSERT INTO mytable VALUES ($1);"
  },
  {
    "Query": "CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$\n    UPDATE bank\n        SET balance = balance - debit\n        WHERE accountno = tf1.accountno;\n    SELECT 1;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "SELECT tf1(17, 100.0);"
  },
  {
    "Query": "CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$\n    UPDATE bank\n        SET balance = balance - debit\n        WHERE accountno = tf1.accountno;\n    SELECT balance FROM bank WHERE accountno = tf1.accountno;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE FUNCTION tf1 (accountno integer, debit numeric) RETURNS numeric AS $$\n    UPDATE bank\n        SET balance = balance - debit\n        WHERE accountno = tf1.accountno\n    RETURNING balance;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE FUNCTION add_em(integer, integer) RETURNS float8 AS $$\n    SELECT $1 + $2;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE FUNCTION new_emp() RETURNS emp AS $$\n    SELECT text 'None' AS name,\n        1000.0 AS salary,\n        25 AS age,\n        point '(2,2)' AS cubicle;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE FUNCTION new_emp() RETURNS emp AS $$\n    SELECT ROW('None', 1000.0, 25, '(2,2)')::emp;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n    SELECT * FROM foo WHERE fooid = $1;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM getfoo(1) AS t1;"
  },
  {
    "Query": "CREATE TABLE tab (y int, z int);"
  },
  {
    "Query": "INSERT INTO tab VALUES (1, 2), (3, 4), (5, 6), (7, 8);"
  },
  {
    "Query": "CREATE FUNCTION sum_n_product_with_tab (x int, OUT sum int, OUT product int)\nRETURNS SETOF record\nAS $$\n    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM sum_n_product_with_tab(10);"
  },
  {
    "Query": "SELECT x, generate_series(1,5) AS g FROM tab;"
  },
  {
    "Query": "SELECT x, g FROM tab, LATERAL generate_series(1,5) AS g;"
  },
  {
    "Query": "SELECT srf1(srf2(x), srf3(y)), srf4(srf5(z)) FROM tab;"
  },
  {
    "Query": "SELECT x, CASE WHEN x > 0 THEN generate_series(1, 5) ELSE 0 END FROM tab;"
  },
  {
    "Query": "SELECT x, CASE WHEN y > 0 THEN generate_series(1, z) ELSE 5 END FROM tab;"
  },
  {
    "Query": "CREATE FUNCTION case_generate_series(cond bool, start int, fin int, els int)\n  RETURNS SETOF int AS $$\nBEGIN\n  IF cond THEN\n    RETURN QUERY SELECT generate_series(start, fin);\n  ELSE\n    RETURN QUERY SELECT els;\n  END IF;\nEND$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT x, case_generate_series(y > 0, 1, z, 5) FROM tab;"
  },
  {
    "Query": "CREATE FUNCTION sum_n_product_with_tab (x int)\nRETURNS TABLE(sum int, product int) AS $$\n    SELECT $1 + tab.y, $1 * tab.y FROM tab;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "SELECT anyleast('abc'::text, 'ABC');"
  },
  {
    "Query": "SELECT anyleast('abc'::text, 'ABC' COLLATE \"C\");"
  },
  {
    "Query": "CREATE FUNCTION anyleast (VARIADIC anyarray) RETURNS anyelement AS $$\n    SELECT min($1[i] COLLATE \"en_US\") FROM generate_subscripts($1, 1) g(i);\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "CREATE TABLE test1 (a boolean, b text);"
  },
  {
    "Query": "INSERT INTO test1 VALUES (TRUE, 'sic est');"
  },
  {
    "Query": "INSERT INTO test1 VALUES (FALSE, 'non est');"
  },
  {
    "Query": "SELECT * FROM test1;"
  },
  {
    "Query": "SELECT * FROM test1 WHERE a"
  },
  {
    "Query": "SELECT * FROM pg_walfile_name_offset(pg_stop_backup());"
  },
  {
    "Query": "SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size\n  FROM pg_partition_tree('measurement');"
  },
  {
    "Query": "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"
  },
  {
    "Query": "SELECT count(*) FROM sometable;"
  },
  {
    "Query": "CREATE TABLE users (\n    nick CITEXT PRIMARY KEY,\n    pass TEXT   NOT NULL\n);"
  },
  {
    "Query": "INSERT INTO users VALUES ( 'larry',  sha256(random()::text::bytea) );"
  },
  {
    "Query": "INSERT INTO users VALUES ( 'Tom',    sha256(random()::text::bytea) );"
  },
  {
    "Query": "INSERT INTO users VALUES ( 'Damian', sha256(random()::text::bytea) );"
  },
  {
    "Query": "INSERT INTO users VALUES ( 'NEAL',   sha256(random()::text::bytea) );"
  },
  {
    "Query": "INSERT INTO users VALUES ( 'BjÃ¸rn',  sha256(random()::text::bytea) );"
  },
  {
    "Query": "SELECT * FROM users WHERE nick = 'Larry';"
  },
  {
    "Query": "ALTER TABLE bobs_table OWNER TO alice;"
  },
  {
    "Query": "REASSIGN OWNED BY doomed_role TO successor_role;"
  },
  {
    "Query": "DROP OWNED BY doomed_role;"
  },
  {
    "Query": "DROP ROLE doomed_role;"
  },
  {
    "Query": "ALTER PUBLICATION noinsert SET (publish = 'update, delete');"
  },
  {
    "Query": "ALTER PUBLICATION mypublication ADD TABLE users, departments;"
  },
  {
    "Query": "CREATE VIEW myview AS\n    SELECT name, temp_lo, temp_hi, prcp, date, location\n        FROM weather, cities\n        WHERE city = name;"
  },
  {
    "Query": "SELECT * FROM myview;"
  },
  {
    "Query": "CREATE FUNCTION t1_count(integer, integer) RETURNS integer AS $$\n    if {![ info exists GD(plan) ]} {\n        # prepare the saved plan on the first call\n        set GD(plan) [ spi_prepare \\\n                \"SELECT count(*) AS cnt FROM t1 WHERE num >= \\$1 AND num <= \\$2\" \\\n                [ list int4 int4 ] ]\n    }\n    spi_execp -count 1 $GD(plan) [ list $1 $2 ]\n    return $cnt\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "SELECT 'doesn't' AS ret"
  },
  {
    "Query": "SELECT 'doesn''t' AS ret"
  },
  {
    "Query": "CREATE FUNCTION add(integer, integer) RETURNS integer\n    AS 'select $1 + $2;'\n    LANGUAGE SQL\n    IMMUTABLE\n    RETURNS NULL ON NULL INPUT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION increment(i integer) RETURNS integer AS $$\n        BEGIN\n                RETURN i + 1;\n        END;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION dup(in int, out f1 int, out f2 text)\n    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$\n    LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM dup(42);"
  },
  {
    "Query": "CREATE TYPE dup_result AS (f1 int, f2 text);"
  },
  {
    "Query": "CREATE FUNCTION dup(int) RETURNS dup_result\n    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$\n    LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM dup(42);"
  },
  {
    "Query": "CREATE FUNCTION dup(int) RETURNS TABLE(f1 int, f2 text)\n    AS $$ SELECT $1, CAST($1 AS text) || ' is text' $$\n    LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM dup(42);"
  },
  {
    "Query": "CREATE FUNCTION check_password(uname TEXT, pass TEXT)\nRETURNS BOOLEAN AS $$\nDECLARE passed BOOLEAN;\nBEGIN\n        SELECT  (pwd = $2) INTO passed\n        FROM    pwds\n        WHERE   username = $1;\n\n        RETURN passed;\nEND;\n$$  LANGUAGE plpgsql\n    SECURITY DEFINER\n\nSET search_path = admin, pg_temp;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "REVOKE ALL ON FUNCTION check_password(uname TEXT, pass TEXT) FROM PUBLIC;"
  },
  {
    "Query": "GRANT EXECUTE ON FUNCTION check_password(uname TEXT, pass TEXT) TO admins;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "CREATE FUNCTION trigfunc_modcount() RETURNS trigger AS $$\n    switch $TG_op {\n        INSERT {\n            set NEW($1) 0\n        }\n        UPDATE {\n            set NEW($1) $OLD($1)\n            incr NEW($1)\n        }\n        default {\n            return OK\n        }\n    }\n    return [array get NEW]\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE TABLE mytab (num integer, description text, modcnt integer);"
  },
  {
    "Query": "CREATE TRIGGER trig_mytab_modcount BEFORE INSERT OR UPDATE ON mytab\n    FOR EACH ROW EXECUTE FUNCTION trigfunc_modcount('modcnt');"
  },
  {
    "Query": "SELECT dblink_is_busy('dtest1');"
  },
  {
    "Query": "SELECT * FROM some_very_long_table_name s JOIN another_fairly_long_name a ON s.id = a.num;"
  },
  {
    "Query": "SELECT * FROM my_table AS m WHERE my_table.a > 5;"
  },
  {
    "Query": "SELECT * FROM people AS mother JOIN people AS child ON mother.id = child.mother_id;"
  },
  {
    "Query": "CREATE TABLE foo (fooid int, foosubid int, fooname text);"
  },
  {
    "Query": "CREATE FUNCTION getfoo(int) RETURNS SETOF foo AS $$\n    SELECT * FROM foo WHERE fooid = $1;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM getfoo(1) AS t1;"
  },
  {
    "Query": "SELECT * FROM foo\n    WHERE foosubid IN (\n                        SELECT foosubid\n                        FROM getfoo(foo.fooid) z\n                        WHERE z.fooid = foo.fooid\n                      );"
  },
  {
    "Query": "CREATE VIEW vw_getfoo AS SELECT * FROM getfoo(1);"
  },
  {
    "Query": "SELECT * FROM vw_getfoo;"
  },
  {
    "Query": "SELECT *\n    FROM dblink('dbname=mydb', 'SELECT proname, prosrc FROM pg_proc')\n      AS t1(proname name, prosrc text)\n    WHERE proname LIKE 'bytea%';"
  },
  {
    "Query": "SELECT *\nFROM ROWS FROM\n    (\n        json_to_recordset('[{\"a\":40,\"b\":\"foo\"},{\"a\":\"100\",\"b\":\"bar\"}]')\n            AS (a INTEGER, b TEXT),\n        generate_series(1, 3)\n    ) AS x (p, q, s)\nORDER BY p;"
  },
  {
    "Query": "SELECT * FROM foo, LATERAL (SELECT * FROM bar WHERE bar.id = foo.bar_id) ss;"
  },
  {
    "Query": "SELECT * FROM foo, bar WHERE bar.id = foo.bar_id;"
  },
  {
    "Query": "SELECT p1.id, p2.id, v1, v2\nFROM polygons p1, polygons p2,\n     LATERAL vertices(p1.poly) v1,\n     LATERAL vertices(p2.poly) v2\nWHERE (v1 <-> v2) < 10 AND p1.id != p2.id;"
  },
  {
    "Query": "SELECT p1.id, p2.id, v1, v2\nFROM polygons p1 CROSS JOIN LATERAL vertices(p1.poly) v1,\n     polygons p2 CROSS JOIN LATERAL vertices(p2.poly) v2\nWHERE (v1 <-> v2) < 10 AND p1.id != p2.id;"
  },
  {
    "Query": "SELECT m.name\nFROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true\nWHERE pname IS NULL;"
  },
  {
    "Query": "SELECT product_id, p.name, (sum(s.units) * p.price) AS sales\n    FROM products p LEFT JOIN sales s USING (product_id)\n    GROUP BY product_id, p.name, p.price;"
  },
  {
    "Query": "SELECT product_id, p.name, (sum(s.units) * (p.price - p.cost)) AS profit\n    FROM products p LEFT JOIN sales s USING (product_id)\n    WHERE s.date > CURRENT_DATE - INTERVAL '4 weeks'\n    GROUP BY product_id, p.name, p.price, p.cost\n    HAVING sum(p.price * s.units) > 5000;"
  },
  {
    "Query": "SELECT EXTRACT(hours from '80 minutes'::interval);"
  },
  {
    "Query": "SELECT EXTRACT(days from '80 hours'::interval)"
  },
  {
    "Query": "UPDATE products SET price = 10 WHERE price = 5;"
  },
  {
    "Query": "UPDATE products SET price = price * 1.10;"
  },
  {
    "Query": "UPDATE mytable SET a = 5, b = 3, c = 1 WHERE a > 0;"
  },
  {
    "Query": "COMMENT ON TABLE mytable IS 'This is my table.';"
  },
  {
    "Query": "COMMENT ON TABLE mytable IS NULL;"
  },
  {
    "Query": "COMMENT ON ACCESS METHOD gin IS 'GIN index access method';"
  },
  {
    "Query": "COMMENT ON AGGREGATE my_aggregate (double precision) IS 'Computes sample variance';"
  },
  {
    "Query": "COMMENT ON CAST (text AS int4) IS 'Allow casts from text to int4';"
  },
  {
    "Query": "COMMENT ON COLLATION \"fr_CA\" IS 'Canadian French';"
  },
  {
    "Query": "COMMENT ON COLUMN my_table.my_column IS 'Employee ID number';"
  },
  {
    "Query": "COMMENT ON CONVERSION my_conv IS 'Conversion to UTF8';"
  },
  {
    "Query": "COMMENT ON CONSTRAINT bar_col_cons ON bar IS 'Constrains column col';"
  },
  {
    "Query": "COMMENT ON CONSTRAINT dom_col_constr ON DOMAIN dom IS 'Constrains col of domain';"
  },
  {
    "Query": "COMMENT ON DATABASE my_database IS 'Development Database';"
  },
  {
    "Query": "COMMENT ON DOMAIN my_domain IS 'Email Address Domain';"
  },
  {
    "Query": "COMMENT ON EVENT TRIGGER abort_ddl IS 'Aborts all DDL commands';"
  },
  {
    "Query": "COMMENT ON EXTENSION hstore IS 'implements the hstore data type';"
  },
  {
    "Query": "COMMENT ON FOREIGN DATA WRAPPER mywrapper IS 'my foreign data wrapper';"
  },
  {
    "Query": "COMMENT ON FOREIGN TABLE my_foreign_table IS 'Employee Information in other database';"
  },
  {
    "Query": "COMMENT ON FUNCTION my_function (timestamp) IS 'Returns Roman Numeral';"
  },
  {
    "Query": "COMMENT ON INDEX my_index IS 'Enforces uniqueness on employee ID';"
  },
  {
    "Query": "COMMENT ON LANGUAGE plpython IS 'Python support for stored procedures';"
  },
  {
    "Query": "COMMENT ON LARGE OBJECT 346344 IS 'Planning document';"
  },
  {
    "Query": "COMMENT ON MATERIALIZED VIEW my_matview IS 'Summary of order history';"
  },
  {
    "Query": "COMMENT ON OPERATOR ^ (text, text) IS 'Performs intersection of two texts';"
  },
  {
    "Query": "COMMENT ON OPERATOR - (NONE, integer) IS 'Unary minus';"
  },
  {
    "Query": "COMMENT ON OPERATOR CLASS int4ops USING btree IS '4 byte integer operators for btrees';"
  },
  {
    "Query": "COMMENT ON OPERATOR FAMILY integer_ops USING btree IS 'all integer operators for btrees';"
  },
  {
    "Query": "COMMENT ON POLICY my_policy ON mytable IS 'Filter rows by users';"
  },
  {
    "Query": "COMMENT ON PROCEDURE my_proc (integer, integer) IS 'Runs a report';"
  },
  {
    "Query": "COMMENT ON PUBLICATION alltables IS 'Publishes all operations on all tables';"
  },
  {
    "Query": "COMMENT ON ROLE my_role IS 'Administration group for finance tables';"
  },
  {
    "Query": "COMMENT ON ROUTINE my_routine (integer, integer) IS 'Runs a routine (which is a function or procedure)';"
  },
  {
    "Query": "COMMENT ON RULE my_rule ON my_table IS 'Logs updates of employee records';"
  },
  {
    "Query": "COMMENT ON SCHEMA my_schema IS 'Departmental data';"
  },
  {
    "Query": "COMMENT ON SEQUENCE my_sequence IS 'Used to generate primary keys';"
  },
  {
    "Query": "COMMENT ON SERVER myserver IS 'my foreign server';"
  },
  {
    "Query": "COMMENT ON STATISTICS my_statistics IS 'Improves planner row estimations';"
  },
  {
    "Query": "COMMENT ON SUBSCRIPTION alltables IS 'Subscription for all operations on all tables';"
  },
  {
    "Query": "COMMENT ON TABLE my_schema.my_table IS 'Employee Information';"
  },
  {
    "Query": "COMMENT ON TABLESPACE my_tablespace IS 'Tablespace for indexes';"
  },
  {
    "Query": "COMMENT ON TEXT SEARCH CONFIGURATION my_config IS 'Special word filtering';"
  },
  {
    "Query": "COMMENT ON TEXT SEARCH DICTIONARY swedish IS 'Snowball stemmer for Swedish language';"
  },
  {
    "Query": "COMMENT ON TEXT SEARCH PARSER my_parser IS 'Splits text into words';"
  },
  {
    "Query": "COMMENT ON TEXT SEARCH TEMPLATE snowball IS 'Snowball stemmer';"
  },
  {
    "Query": "COMMENT ON TRANSFORM FOR hstore LANGUAGE plpythonu IS 'Transform between hstore and Python dict';"
  },
  {
    "Query": "COMMENT ON TRIGGER my_trigger ON my_table IS 'Used for RI';"
  },
  {
    "Query": "COMMENT ON TYPE complex IS 'Complex number data type';"
  },
  {
    "Query": "COMMENT ON VIEW my_view IS 'View of departmental costs';"
  },
  {
    "Query": "VACUUM (VERBOSE, ANALYZE) onek;"
  },
  {
    "Query": "SELECT setseed(value);"
  },
  {
    "Query": "SET search_path TO my_schema, public;"
  },
  {
    "Query": "SELECT soundex('hello world!');"
  },
  {
    "Query": "SELECT soundex('Anne'), soundex('Ann'), difference('Anne', 'Ann');"
  },
  {
    "Query": "SELECT soundex('Anne'), soundex('Andrew'), difference('Anne', 'Andrew');"
  },
  {
    "Query": "SELECT soundex('Anne'), soundex('Margaret'), difference('Anne', 'Margaret');"
  },
  {
    "Query": "CREATE TABLE s (nm text);"
  },
  {
    "Query": "INSERT INTO s VALUES ('john');"
  },
  {
    "Query": "INSERT INTO s VALUES ('joan');"
  },
  {
    "Query": "INSERT INTO s VALUES ('wobbly');"
  },
  {
    "Query": "INSERT INTO s VALUES ('jack');"
  },
  {
    "Query": "SELECT * FROM s WHERE soundex(nm) = soundex('john');"
  },
  {
    "Query": "SELECT * FROM s WHERE difference(s.nm, 'john') > 2;"
  },
  {
    "Query": "SELECT * FROM foo"
  },
  {
    "Query": "SELECT * FROM employee WHERE employee_id = 456"
  },
  {
    "Query": "select 1;"
  },
  {
    "Query": "select 2;"
  },
  {
    "Query": "select 3;"
  },
  {
    "Query": "select 3;"
  },
  {
    "Query": "SELECT first, second, first > 2 AS gt2 FROM my_table;"
  },
  {
    "Query": "SELECT '2018-03-11 02:30'::timestamptz;"
  },
  {
    "Query": "SELECT '2018-11-04 01:30'::timestamptz;"
  },
  {
    "Query": "SELECT '2018-11-04 01:30 EDT'::timestamptz;"
  },
  {
    "Query": "ALTER ROLE davide WITH PASSWORD 'hu8jmn3';"
  },
  {
    "Query": "ALTER ROLE davide WITH PASSWORD NULL;"
  },
  {
    "Query": "ALTER ROLE chris VALID UNTIL 'May 4 12:00:00 2015 +1';"
  },
  {
    "Query": "ALTER ROLE fred VALID UNTIL 'infinity';"
  },
  {
    "Query": "ALTER ROLE miriam CREATEROLE CREATEDB;"
  },
  {
    "Query": "ALTER ROLE worker_bee SET maintenance_work_mem = 100000;"
  },
  {
    "Query": "ALTER ROLE fred IN DATABASE devel SET client_min_messages = DEBUG;"
  },
  {
    "Query": "CREATE OPERATOR CLASS gist__int_ops\n    DEFAULT FOR TYPE _int4 USING gist AS\n        OPERATOR        3       &&,\n        OPERATOR        6       = (anyarray, anyarray),\n        OPERATOR        7       @>,\n        OPERATOR        8       <@,\n        OPERATOR        20      @@ (_int4, query_int),\n        FUNCTION        1       g_int_consistent (internal, _int4, smallint, oid, internal),\n        FUNCTION        2       g_int_union (internal, internal),\n        FUNCTION        3       g_int_compress (internal),\n        FUNCTION        4       g_int_decompress (internal),\n        FUNCTION        5       g_int_penalty (internal, internal, internal),\n        FUNCTION        6       g_int_picksplit (internal, internal),\n        FUNCTION        7       g_int_same (_int4, _int4, internal);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric DEFAULT 9.99\n);"
  },
  {
    "Query": "DROP TEXT SEARCH CONFIGURATION my_english;"
  },
  {
    "Query": "CREATE FUNCTION test(int) RETURNS int\n    AS 'filename', 'test_1arg'\n    LANGUAGE C;"
  },
  {
    "Query": "CREATE FUNCTION test(int, int) RETURNS int\n    AS 'filename', 'test_2arg'\n    LANGUAGE C;"
  },
  {
    "Query": "DECLARE liahona CURSOR FOR SELECT * FROM films;"
  },
  {
    "Query": "SELECT uuid_generate_v3(uuid_ns_url(), 'http://www.postgresql.org');"
  },
  {
    "Query": "CREATE ROLE joe LOGIN INHERIT;"
  },
  {
    "Query": "CREATE ROLE admin NOINHERIT;"
  },
  {
    "Query": "CREATE ROLE wheel NOINHERIT;"
  },
  {
    "Query": "GRANT admin TO joe;"
  },
  {
    "Query": "GRANT wheel TO admin;"
  },
  {
    "Query": "SET ROLE admin;"
  },
  {
    "Query": "SET ROLE wheel;"
  },
  {
    "Query": "SET ROLE joe;"
  },
  {
    "Query": "SET ROLE NONE;"
  },
  {
    "Query": "RESET ROLE;"
  },
  {
    "Query": "SELECT title\nFROM pgweb\nWHERE to_tsvector('english', body) @@ to_tsquery('english', 'friend');"
  },
  {
    "Query": "SELECT title\nFROM pgweb\nWHERE to_tsvector(body) @@ to_tsquery('friend');"
  },
  {
    "Query": "SELECT title\nFROM pgweb\nWHERE to_tsvector(title || ' ' || body) @@ to_tsquery('create & table')\nORDER BY last_mod_date DESC\nLIMIT 10;"
  },
  {
    "Query": "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', body));"
  },
  {
    "Query": "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector(config_name, body));"
  },
  {
    "Query": "CREATE INDEX pgweb_idx ON pgweb USING GIN (to_tsvector('english', title || ' ' || body));"
  },
  {
    "Query": "ALTER TABLE pgweb\n    ADD COLUMN textsearchable_index_col tsvector\n               GENERATED ALWAYS AS (to_tsvector('english', coalesce(title, '') || ' ' || coalesce(body, ''))) STORED;"
  },
  {
    "Query": "CREATE INDEX textsearch_idx ON pgweb USING GIN (textsearchable_index_col);"
  },
  {
    "Query": "SELECT title\nFROM pgweb\nWHERE textsearchable_index_col @@ to_tsquery('create & table')\nORDER BY last_mod_date DESC\nLIMIT 10;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "ROLLBACK;"
  },
  {
    "Query": "EXPLAIN SELECT * FROM foo;"
  },
  {
    "Query": "EXPLAIN (FORMAT JSON) SELECT * FROM foo;"
  },
  {
    "Query": "EXPLAIN SELECT * FROM foo WHERE i = 4;"
  },
  {
    "Query": "EXPLAIN (FORMAT YAML) SELECT * FROM foo WHERE i='4';"
  },
  {
    "Query": "EXPLAIN (COSTS FALSE) SELECT * FROM foo WHERE i = 4;"
  },
  {
    "Query": "EXPLAIN SELECT sum(i) FROM foo WHERE i < 10;"
  },
  {
    "Query": "PREPARE query(int, int) AS SELECT sum(bar) FROM test\n    WHERE id > $1 AND id < $2\n    GROUP BY foo"
  },
  {
    "Query": "EXPLAIN ANALYZE EXECUTE query(100, 200);"
  },
  {
    "Query": "UPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';"
  },
  {
    "Query": "UPDATE branches SET balance = balance - 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Alice');"
  },
  {
    "Query": "UPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';"
  },
  {
    "Query": "UPDATE branches SET balance = balance + 100.00\n    WHERE name = (SELECT branch_name FROM accounts WHERE name = 'Bob');"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "UPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "UPDATE accounts SET balance = balance - 100.00\n    WHERE name = 'Alice';"
  },
  {
    "Query": "SAVEPOINT my_savepoint;"
  },
  {
    "Query": "UPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Bob';"
  },
  {
    "Query": "ROLLBACK TO my_savepoint;"
  },
  {
    "Query": "UPDATE accounts SET balance = balance + 100.00\n    WHERE name = 'Wally';"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "CREATE PUBLICATION mypub FOR TABLE users, departments;"
  },
  {
    "Query": "CREATE SUBSCRIPTION mysub CONNECTION 'dbname=foo host=bar user=repuser' PUBLICATION mypub;"
  },
  {
    "Query": "CREATE TABLE test (a int4);"
  },
  {
    "Query": "CREATE INDEX testidx ON test USING GIST (a);"
  },
  {
    "Query": "SELECT * FROM test WHERE a < 10;"
  },
  {
    "Query": "SELECT *, a <-> 42 AS dist FROM test ORDER BY a <-> 42 LIMIT 10;"
  },
  {
    "Query": "CREATE TABLE zoo (\n  cage   INTEGER,\n  animal TEXT,\n  EXCLUDE USING GIST (cage WITH =, animal WITH <>)\n);"
  },
  {
    "Query": "INSERT INTO zoo VALUES(123, 'zebra');"
  },
  {
    "Query": "INSERT INTO zoo VALUES(124, 'lion')"
  },
  {
    "Query": "PREPARE statement_name(integer, integer) AS SELECT $1 < $2;"
  },
  {
    "Query": "CREATE TABLE my_config (key text, value text);"
  },
  {
    "Query": "CREATE SEQUENCE my_config_seq;"
  },
  {
    "Query": "SELECT pg_catalog.pg_extension_config_dump('my_config', '');"
  },
  {
    "Query": "SELECT pg_catalog.pg_extension_config_dump('my_config_seq', '');"
  },
  {
    "Query": "CREATE TABLE my_config (key text, value text, standard_entry boolean);"
  },
  {
    "Query": "SELECT pg_catalog.pg_extension_config_dump('my_config', 'WHERE NOT standard_entry');"
  },
  {
    "Query": "SELECT * FROM pg_extension_update_paths('extension_name');"
  },
  {
    "Query": "CREATE TYPE pair AS ( k text, v text )"
  },
  {
    "Query": "CREATE FUNCTION pair(text, text)\nRETURNS pair LANGUAGE SQL AS 'SELECT ROW($1, $2)::@extschema@.pair;';"
  },
  {
    "Query": "CREATE OPERATOR ~> (LEFTARG = text, RIGHTARG = text, FUNCTION = pair);"
  },
  {
    "Query": "CREATE FUNCTION lower(pair)\nRETURNS pair LANGUAGE SQL\nAS 'SELECT ROW(lower($1.k), lower($1.v))::@extschema@.pair;'\nSET search_path = pg_temp;"
  },
  {
    "Query": "CREATE FUNCTION pair_concat(pair, pair)\nRETURNS pair LANGUAGE SQL\nAS 'SELECT ROW($1.k OPERATOR(pg_catalog.||) $2.k,\n               $1.v OPERATOR(pg_catalog.||) $2.v)::@extschema@.pair;';"
  },
  {
    "Query": "CREATE PROCEDURE transaction_test1()\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    FOR i IN 0..9 LOOP\n        INSERT INTO test1 (a) VALUES (i);\n        IF i % 2 = 0 THEN\n            COMMIT;\n        ELSE\n            ROLLBACK;\n        END IF;\n    END LOOP;\nEND;\n$$;"
  },
  {
    "Query": "CALL transaction_test1();"
  },
  {
    "Query": "CREATE PROCEDURE transaction_test2()\nLANGUAGE plpgsql\nAS $$\nDECLARE\n    r RECORD;\nBEGIN\n    FOR r IN SELECT * FROM test2 ORDER BY x LOOP\n        INSERT INTO test1 (a) VALUES (r.x);\n        COMMIT;\n    END LOOP;\nEND;\n$$;"
  },
  {
    "Query": "CALL transaction_test2();"
  },
  {
    "Query": "ALTER SYSTEM SET wal_level = replica;"
  },
  {
    "Query": "ALTER SYSTEM RESET wal_level;"
  },
  {
    "Query": "ALTER VIEW foo RENAME TO bar;"
  },
  {
    "Query": "CREATE TABLE base_table (id int, ts timestamptz);"
  },
  {
    "Query": "CREATE VIEW a_view AS SELECT * FROM base_table;"
  },
  {
    "Query": "ALTER VIEW a_view ALTER COLUMN ts SET DEFAULT now();"
  },
  {
    "Query": "INSERT INTO base_table(id) VALUES(1);"
  },
  {
    "Query": "INSERT INTO a_view(id) VALUES(2);"
  },
  {
    "Query": "CREATE TEXT SEARCH CONFIGURATION public.english ( COPY = pg_catalog.english );"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY english_ispell (\n    TEMPLATE = ispell,\n    DictFile = english,\n    AffFile = english,\n    StopWords = english\n);"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION public.english\n   ALTER MAPPING FOR asciiword WITH english_ispell, english_stem;"
  },
  {
    "Query": "CREATE FUNCTION messages_trigger() RETURNS trigger AS $$\nbegin\n  new.tsv :=\n     setweight(to_tsvector('pg_catalog.english', coalesce(new.title,'')), 'A') ||\n     setweight(to_tsvector('pg_catalog.english', coalesce(new.body,'')), 'D');\n  return new;\nend\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER tsvectorupdate BEFORE INSERT OR UPDATE\n    ON messages FOR EACH ROW EXECUTE FUNCTION messages_trigger();"
  },
  {
    "Query": "SELECT * FROM ts_stat('SELECT vector FROM apod')\nORDER BY nentry DESC, ndoc DESC, word\nLIMIT 10;"
  },
  {
    "Query": "SELECT * FROM ts_stat('SELECT vector FROM apod', 'ab')\nORDER BY nentry DESC, ndoc DESC, word\nLIMIT 10;"
  },
  {
    "Query": "CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow',\n                             'green', 'blue', 'purple');"
  },
  {
    "Query": "CREATE TABLE my_colors (color rainbow, note text);"
  },
  {
    "Query": "CREATE FUNCTION get_color_note (rainbow) RETURNS text AS\n  'SELECT note FROM my_colors WHERE color = $1'\n  LANGUAGE SQL;"
  },
  {
    "Query": "CREATE FUNCTION somefunc(integer, text) RETURNS integer\nAS 'function body text'\nLANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION somefunc() RETURNS integer AS $$\n<< outerblock >>\nDECLARE\n    quantity integer := 30;\nBEGIN\n    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 30\n    quantity := 50;\n    --\n    -- Create a subblock\n    --\n    DECLARE\n        quantity integer := 80;\n    BEGIN\n        RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 80\n        RAISE NOTICE 'Outer quantity here is %', outerblock.quantity;  -- Prints 50\n    END;\n\n    RAISE NOTICE 'Quantity here is %', quantity;  -- Prints 50\n\n    RETURN quantity;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "UPDATE films SET kind = 'Dramatic' WHERE kind = 'Drama';"
  },
  {
    "Query": "UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\n  WHERE city = 'San Francisco' AND date = '2003-07-03';"
  },
  {
    "Query": "UPDATE weather SET temp_lo = temp_lo+1, temp_hi = temp_lo+15, prcp = DEFAULT\n  WHERE city = 'San Francisco' AND date = '2003-07-03'\n  RETURNING temp_lo, temp_hi, prcp;"
  },
  {
    "Query": "UPDATE weather SET (temp_lo, temp_hi, prcp) = (temp_lo+1, temp_lo+15, DEFAULT)\n  WHERE city = 'San Francisco' AND date = '2003-07-03';"
  },
  {
    "Query": "UPDATE employees SET sales_count = sales_count + 1 FROM accounts\n  WHERE accounts.name = 'Acme Corporation'\n  AND employees.id = accounts.sales_person;"
  },
  {
    "Query": "UPDATE employees SET sales_count = sales_count + 1 WHERE id =\n  (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation');"
  },
  {
    "Query": "UPDATE accounts SET (contact_first_name, contact_last_name) =\n    (SELECT first_name, last_name FROM salesmen\n     WHERE salesmen.id = accounts.sales_id);"
  },
  {
    "Query": "UPDATE accounts SET contact_first_name = first_name,\n                    contact_last_name = last_name\n  FROM salesmen WHERE salesmen.id = accounts.sales_id;"
  },
  {
    "Query": "UPDATE summary s SET (sum_x, sum_y, avg_x, avg_y) =\n    (SELECT sum(x), sum(y), avg(x), avg(y) FROM data d\n     WHERE d.group_id = s.group_id);"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "SAVEPOINT sp1;"
  },
  {
    "Query": "INSERT INTO wines VALUES('Chateau Lafite 2003', '24');"
  },
  {
    "Query": "ROLLBACK TO sp1;"
  },
  {
    "Query": "UPDATE wines SET stock = stock + 24 WHERE winename = 'Chateau Lafite 2003';"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "UPDATE films SET kind = 'Dramatic' WHERE CURRENT OF c_films;"
  },
  {
    "Query": "DO $$\n    # PL/Perl code\n$$ LANGUAGE plperl"
  },
  {
    "Query": "CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n    if ($_[0] > $_[1]) { return $_[0]; }\n    return $_[1];\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE FUNCTION perl_max (integer, integer) RETURNS integer AS $$\n    my ($x, $y) = @_;\n    if (not defined $x) {\n        return undef if not defined $y;\n        return $y;\n    }\n    return $x if not defined $y;\n    return $x if $x > $y;\n    return $y;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE EXTENSION bool_plperl;"
  },
  {
    "Query": "CREATE FUNCTION perl_and(bool, bool) RETURNS bool\nTRANSFORM FOR TYPE bool\nAS $$\n  my ($a, $b) = @_;\n  return $a && $b;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE function returns_array()\nRETURNS text[][] AS $$\n    return [['a\"b','c,d'],['e\\\\f','g']];\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "select returns_array();"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION concat_array_elements(text[]) RETURNS TEXT AS $$\n    my $arg = shift;\n    my $result = \"\";\n    return undef if (!defined $arg);\n\n    # as an array reference\n    for (@$arg) {\n        $result .= $_;\n    }\n\n    # also works as a string\n    $result .= $arg;\n\n    return $result;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT concat_array_elements(ARRAY['PL','/','Perl']);"
  },
  {
    "Query": "CREATE TABLE employee (\n    name text,\n    basesalary integer,\n    bonus integer\n);"
  },
  {
    "Query": "CREATE FUNCTION empcomp(employee) RETURNS integer AS $$\n    my ($emp) = @_;\n    return $emp->{basesalary} + $emp->{bonus};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT name, empcomp(employee.*) FROM employee;"
  },
  {
    "Query": "CREATE TYPE testrowperl AS (f1 integer, f2 text, f3 text);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION perl_row() RETURNS testrowperl AS $$\n    return {f2 => 'hello', f1 => 1, f3 => 'world'};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT * FROM perl_row();"
  },
  {
    "Query": "CREATE PROCEDURE perl_triple(INOUT a integer, INOUT b integer) AS $$\n    my ($a, $b) = @_;\n    return {a => $a * 3, b => $b * 3};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CALL perl_triple(5, 10);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION perl_set_int(int)\nRETURNS SETOF INTEGER AS $$\n    foreach (0..$_[0]) {\n        return_next($_);\n    }\n    return undef;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT * FROM perl_set_int(5);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION perl_set()\nRETURNS SETOF testrowperl AS $$\n    return_next({ f1 => 1, f2 => 'Hello', f3 => 'World' });\n    return_next({ f1 => 2, f2 => 'Hello', f3 => 'PostgreSQL' });\n    return_next({ f1 => 3, f2 => 'Hello', f3 => 'PL/Perl' });\n    return undef;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION perl_set_int(int) RETURNS SETOF INTEGER AS $$\n    return [0..$_[0]];\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT * FROM perl_set_int(5);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION perl_set() RETURNS SETOF testrowperl AS $$\n    return [\n        { f1 => 1, f2 => 'Hello', f3 => 'World' },\n        { f1 => 2, f2 => 'Hello', f3 => 'PostgreSQL' },\n        { f1 => 3, f2 => 'Hello', f3 => 'PL/Perl' }\n    ];\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT * FROM perl_set();"
  },
  {
    "Query": "DO $$\n    # PL/Python code\n$$ LANGUAGE plpythonu"
  },
  {
    "Query": "CREATE TABLE ttest (\n    x integer\n);"
  },
  {
    "Query": "CREATE FUNCTION trigf() RETURNS trigger\n    AS 'filename'\n    LANGUAGE C;"
  },
  {
    "Query": "CREATE TRIGGER tbefore BEFORE INSERT OR UPDATE OR DELETE ON ttest\n    FOR EACH ROW EXECUTE FUNCTION trigf();"
  },
  {
    "Query": "CREATE TRIGGER tafter AFTER INSERT OR UPDATE OR DELETE ON ttest\n    FOR EACH ROW EXECUTE FUNCTION trigf();"
  },
  {
    "Query": "ALTER TABLESPACE index_space RENAME TO fast_raid;"
  },
  {
    "Query": "ALTER TABLESPACE index_space OWNER TO mary;"
  },
  {
    "Query": "CLOSE ALL;"
  },
  {
    "Query": "SET SESSION AUTHORIZATION DEFAULT;"
  },
  {
    "Query": "RESET ALL;"
  },
  {
    "Query": "DEALLOCATE ALL;"
  },
  {
    "Query": "UNLISTEN *;"
  },
  {
    "Query": "SELECT pg_advisory_unlock_all();"
  },
  {
    "Query": "DISCARD PLANS;"
  },
  {
    "Query": "DISCARD TEMP;"
  },
  {
    "Query": "DISCARD SEQUENCES;"
  },
  {
    "Query": "MOVE curs1;"
  },
  {
    "Query": "MOVE LAST FROM curs3;"
  },
  {
    "Query": "MOVE RELATIVE -2 FROM curs4;"
  },
  {
    "Query": "MOVE FORWARD 2 FROM curs4;"
  },
  {
    "Query": "UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;"
  },
  {
    "Query": "CLOSE curs1;"
  },
  {
    "Query": "CREATE TABLE test (col text);"
  },
  {
    "Query": "INSERT INTO test VALUES ('123');"
  },
  {
    "Query": "CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '\nBEGIN\n    OPEN $1 FOR SELECT col FROM test;\n    RETURN $1;\nEND;\n' LANGUAGE plpgsql;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "SELECT reffunc('funccursor');"
  },
  {
    "Query": "FETCH ALL IN funccursor;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "CREATE FUNCTION reffunc2() RETURNS refcursor AS '\nDECLARE\n    ref refcursor;\nBEGIN\n    OPEN ref FOR SELECT col FROM test;\n    RETURN ref;\nEND;\n' LANGUAGE plpgsql;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "SELECT reffunc2();"
  },
  {
    "Query": "FETCH ALL IN \"<unnamed cursor 1>\""
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$\nBEGIN\n    OPEN $1 FOR SELECT * FROM table_1;\n    RETURN NEXT $1;\n    OPEN $2 FOR SELECT * FROM table_2;\n    RETURN NEXT $2;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "SELECT * FROM myfunc('a', 'b');"
  },
  {
    "Query": "FETCH ALL FROM a;"
  },
  {
    "Query": "FETCH ALL FROM b;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "SELECT * FROM pgstattuple('pg_catalog.pg_proc');"
  },
  {
    "Query": "SELECT * FROM pgstatindex('pg_cast_oid_index');"
  },
  {
    "Query": "SELECT * FROM pgstatginindex('test_gin_index');"
  },
  {
    "Query": "select * from pgstathashindex('con_hash_index');"
  },
  {
    "Query": "SELECT * FROM pgstattuple_approx('pg_catalog.pg_proc'::regclass);"
  },
  {
    "Query": "CREATE FUNCTION noddl() RETURNS event_trigger\n    AS 'noddl' LANGUAGE C;"
  },
  {
    "Query": "CREATE EVENT TRIGGER noddl ON ddl_command_start\n    EXECUTE FUNCTION noddl();"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "ALTER EVENT TRIGGER noddl DISABLE;"
  },
  {
    "Query": "CREATE TABLE foo (id serial);"
  },
  {
    "Query": "ALTER EVENT TRIGGER noddl ENABLE;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;"
  },
  {
    "Query": "SELECT * FROM a LEFT JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);"
  },
  {
    "Query": "SELECT * FROM a LEFT JOIN b ON (a.bid = b.id) LEFT JOIN c ON (a.cid = c.id);"
  },
  {
    "Query": "SELECT * FROM a, b, c WHERE a.id = b.id AND b.ref = c.id;"
  },
  {
    "Query": "SELECT * FROM a CROSS JOIN b CROSS JOIN c WHERE a.id = b.id AND b.ref = c.id;"
  },
  {
    "Query": "SELECT * FROM a JOIN (b JOIN c ON (b.ref = c.id)) ON (a.id = b.id);"
  },
  {
    "Query": "SELECT *\nFROM x, y,\n    (SELECT * FROM a, b, c WHERE something) AS ss\nWHERE somethingelse;"
  },
  {
    "Query": "SELECT * FROM x, y, a, b, c WHERE something AND somethingelse;"
  },
  {
    "Query": "INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');"
  },
  {
    "Query": "INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');"
  },
  {
    "Query": "INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)\n    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');"
  },
  {
    "Query": "INSERT INTO weather (date, city, temp_hi, temp_lo)\n    VALUES ('1994-11-29', 'Hayward', 54, 37);"
  },
  {
    "Query": "COPY weather FROM '/home/user/weather.txt';"
  },
  {
    "Query": "ALTER SEQUENCE serial RESTART WITH 105;"
  },
  {
    "Query": "CREATE AGGREGATE sum (complex)\n(\n    sfunc = complex_add,\n    stype = complex,\n    initcond = '(0,0)'\n);"
  },
  {
    "Query": "SELECT sum(a) FROM test_complex;"
  },
  {
    "Query": "CREATE AGGREGATE avg (float8)\n(\n    sfunc = float8_accum,\n    stype = float8[],\n    finalfunc = float8_avg,\n    initcond = '{0,0,0}'\n);"
  },
  {
    "Query": "CREATE AGGREGATE sum (complex)\n(\n    sfunc = complex_add,\n    stype = complex,\n    initcond = '(0,0)',\n    msfunc = complex_add,\n    minvfunc = complex_sub,\n    mstype = complex,\n    minitcond = '(0,0)'\n);"
  },
  {
    "Query": "CREATE AGGREGATE unsafe_sum (float8)\n(\n    stype = float8,\n    sfunc = float8pl,\n    mstype = float8,\n    msfunc = float8pl,\n    minvfunc = float8mi\n);"
  },
  {
    "Query": "SELECT\n  unsafe_sum(x) OVER (ORDER BY n ROWS BETWEEN CURRENT ROW AND 1 FOLLOWING)\nFROM (VALUES (1, 1.0e20::float8),\n             (2, 1.0::float8)) AS v (n,x);"
  },
  {
    "Query": "CREATE AGGREGATE array_accum (anyelement)\n(\n    sfunc = array_append,\n    stype = anyarray,\n    initcond = '{}'\n);"
  },
  {
    "Query": "SELECT attrelid::regclass, array_accum(attname)\n    FROM pg_attribute\n    WHERE attnum > 0 AND attrelid = 'pg_tablespace'::regclass\n    GROUP BY attrelid;"
  },
  {
    "Query": "SELECT attrelid::regclass, array_accum(atttypid::regtype)\n    FROM pg_attribute\n    WHERE attnum > 0 AND attrelid = 'pg_tablespace'::regclass\n    GROUP BY attrelid"
  },
  {
    "Query": "CREATE AGGREGATE array_agg (anynonarray)\n(\n    sfunc = array_agg_transfn,\n    stype = internal,\n    finalfunc = array_agg_finalfn,\n    finalfunc_extra\n);"
  },
  {
    "Query": "CREATE AGGREGATE percentile_disc (float8 ORDER BY anyelement)\n(\n    sfunc = ordered_set_transition,\n    stype = internal,\n    finalfunc = percentile_disc_final,\n    finalfunc_extra\n);"
  },
  {
    "Query": "SELECT percentile_disc(0.5) WITHIN GROUP (ORDER BY income) FROM households;"
  },
  {
    "Query": "ALTER CONVERSION iso_8859_1_to_utf8 RENAME TO latin1_to_unicode;"
  },
  {
    "Query": "ALTER CONVERSION iso_8859_1_to_utf8 OWNER TO joe;"
  },
  {
    "Query": "CREATE TABLE weather (\n    city            varchar(80),\n    temp_lo         int,\ntemp_hi         int,\nprcp            real,\ndate            date\n);"
  },
  {
    "Query": "CREATE TABLE cities (\n    name            varchar(80),\n    location        point\n);"
  },
  {
    "Query": "CREATE MATERIALIZED VIEW mymatview AS SELECT * FROM mytab;"
  },
  {
    "Query": "CREATE TABLE mymatview AS SELECT * FROM mytab;"
  },
  {
    "Query": "REFRESH MATERIALIZED VIEW mymatview;"
  },
  {
    "Query": "CREATE TABLE invoice (\n    invoice_no    integer        PRIMARY KEY,\n    seller_no     integer,\ninvoice_date  date,\ninvoice_amt   numeric(13,2)\n);"
  },
  {
    "Query": "CREATE MATERIALIZED VIEW sales_summary AS\n  SELECT\n      seller_no,\n      invoice_date,\n      sum(invoice_amt)::numeric(13,2) as sales_amt\n    FROM invoice\n    WHERE invoice_date < CURRENT_DATE\n    GROUP BY\n      seller_no,\n      invoice_date;"
  },
  {
    "Query": "CREATE UNIQUE INDEX sales_summary_seller\n  ON sales_summary (seller_no, invoice_date);"
  },
  {
    "Query": "REFRESH MATERIALIZED VIEW sales_summary;"
  },
  {
    "Query": "CREATE EXTENSION file_fdw;"
  },
  {
    "Query": "CREATE SERVER local_file FOREIGN DATA WRAPPER file_fdw;"
  },
  {
    "Query": "CREATE FOREIGN TABLE words (word text NOT NULL)\n  SERVER local_file\n  OPTIONS (filename '/usr/share/dict/words');"
  },
  {
    "Query": "CREATE MATERIALIZED VIEW wrd AS SELECT * FROM words;"
  },
  {
    "Query": "CREATE UNIQUE INDEX wrd_word ON wrd (word);"
  },
  {
    "Query": "CREATE EXTENSION pg_trgm;"
  },
  {
    "Query": "CREATE INDEX wrd_trgm ON wrd USING gist (word gist_trgm_ops);"
  },
  {
    "Query": "VACUUM ANALYZE wrd;"
  },
  {
    "Query": "SELECT count(*) FROM words WHERE word = 'caterpiler';"
  },
  {
    "Query": "SELECT word FROM words ORDER BY word <-> 'caterpiler' LIMIT 10;"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION astro_en\n    ADD MAPPING FOR asciiword WITH astrosyn, english_ispell, english_stem;"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY public.simple_dict (\n    TEMPLATE = pg_catalog.simple,\n    STOPWORDS = english\n);"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY thesaurus_simple (\n    TEMPLATE = thesaurus,\n    DictFile = mythesaurus,\n    Dictionary = pg_catalog.english_stem\n);"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION russian\n    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart\n    WITH thesaurus_simple;"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY thesaurus_astro (\n    TEMPLATE = thesaurus,\n    DictFile = thesaurus_astro,\n    Dictionary = english_stem\n);"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION russian\n    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart\n    WITH thesaurus_astro, english_stem;"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY english_hunspell (\n    TEMPLATE = ispell,\n    DictFile = en_us,\n    AffFile = en_us,\n    Stopwords = english);"
  },
  {
    "Query": "SELECT ts_lexize('norwegian_ispell', 'overbuljongterningpakkmesterassistent');"
  },
  {
    "Query": "SELECT ts_lexize('norwegian_ispell', 'sjokoladefabrikk')"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY english_stem (\n    TEMPLATE = snowball,\n    Language = english,\n    StopWords = english\n);"
  },
  {
    "Query": "SELECT regexp_match('foobarbequebaz', 'bar.*que');"
  },
  {
    "Query": "SELECT regexp_match('foobarbequebaz', '(bar)(beque)')"
  },
  {
    "Query": "SELECT (regexp_match('foobarbequebaz', 'bar.*que'))[1];"
  },
  {
    "Query": "SELECT regexp_matches('foo', 'not there');"
  },
  {
    "Query": "SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g')"
  },
  {
    "Query": "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"
  },
  {
    "Query": "SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', '\\s+') AS foo;"
  },
  {
    "Query": "SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', '\\s+')"
  },
  {
    "Query": "SELECT foo FROM regexp_split_to_table('the quick brown fox', '\\s*') AS foo"
  },
  {
    "Query": "SELECT title || ' ' ||  author || ' ' ||  abstract || ' ' || body AS document\nFROM messages\nWHERE mid = 12;"
  },
  {
    "Query": "SELECT m.title || ' ' || m.author || ' ' || m.abstract || ' ' || d.body AS document\nFROM messages m, docs d\nWHERE m.mid = d.did AND m.mid = 12;"
  },
  {
    "Query": "SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector @@ 'cat & rat'::tsquery;"
  },
  {
    "Query": "SELECT 'fat & cow'::tsquery @@ 'a fat cat sat on a mat and ate a fat rat'::tsvector"
  },
  {
    "Query": "SELECT to_tsvector('fat cats ate fat rats') @@ to_tsquery('fat & rat');"
  },
  {
    "Query": "SELECT 'fat cats ate fat rats'::tsvector @@ to_tsquery('fat & rat');"
  },
  {
    "Query": "SELECT to_tsvector('fatal error') @@ to_tsquery('fatal <-> error');"
  },
  {
    "Query": "SELECT to_tsvector('error is not fatal') @@ to_tsquery('fatal <-> error')"
  },
  {
    "Query": "SELECT phraseto_tsquery('cats ate rats');"
  },
  {
    "Query": "SELECT phraseto_tsquery('the cats ate the rats')"
  },
  {
    "Query": "CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n    if {$1 > $2} {return $1}\n    return $2\n$$ LANGUAGE pltcl STRICT;"
  },
  {
    "Query": "CREATE FUNCTION tcl_max(integer, integer) RETURNS integer AS $$\n    if {[argisnull 1]} {\n        if {[argisnull 2]} { return_null }\n        return $2\n    }\n    if {[argisnull 2]} { return $1 }\n    if {$1 > $2} {return $1}\n    return $2\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE TABLE employee (\n    name text,\n    salary integer,\n    age integer\n);"
  },
  {
    "Query": "CREATE FUNCTION overpaid(employee) RETURNS boolean AS $$\n    if {200000.0 < $1(salary)} {\n        return \"t\"\n    }\n    if {$1(age) < 30 && 100000.0 < $1(salary)} {\n        return \"t\"\n    }\n    return \"f\"\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE FUNCTION square_cube(in int, out squared int, out cubed int) AS $$\n    return [list squared [expr {$1 * $1}] cubed [expr {$1 * $1 * $1}]]\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE PROCEDURE tcl_triple(INOUT a integer, INOUT b integer) AS $$\n    return [list a [expr {$1 * 3}] b [expr {$2 * 3}]]\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CALL tcl_triple(5, 10);"
  },
  {
    "Query": "CREATE FUNCTION raise_pay(employee, delta int) RETURNS employee AS $$\n    set 1(salary) [expr {$1(salary) + $2}]\n    return [array get 1]\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE FUNCTION sequence(int, int) RETURNS SETOF int AS $$\n    for {set i $1} {$i < $2} {incr i} {\n        return_next $i\n    }\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE FUNCTION table_of_squares(int, int) RETURNS TABLE (x int, x2 int) AS $$\n    for {set i $1} {$i < $2} {incr i} {\n        return_next [list x $i x2 [expr {$i * $i}]]\n    }\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "DO $$DECLARE r record"
  },
  {
    "Query": "CREATE TABLE films (\n    code        char(5) CONSTRAINT firstkey PRIMARY KEY,\n    title       varchar(40) NOT NULL,\n    did         integer NOT NULL,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n     did    integer PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,\n     name   varchar(40) NOT NULL CHECK (name <> '')\n);"
  },
  {
    "Query": "CREATE TABLE array_int (\n    vector  int[][]\n);"
  },
  {
    "Query": "CREATE TABLE films (\n    code        char(5),\n    title       varchar(40),\n    did         integer,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute,\n    CONSTRAINT production UNIQUE(date_prod)\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer CHECK (did > 100),\n    name    varchar(40)\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    CONSTRAINT con1 CHECK (did > 100 AND name <> '')\n);"
  },
  {
    "Query": "CREATE TABLE films (\n    code        char(5),\n    title       varchar(40),\n    did         integer,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute,\n    CONSTRAINT code_title PRIMARY KEY(code,title)\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    PRIMARY KEY(did)\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer PRIMARY KEY,\n    name    varchar(40)\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    name      varchar(40) DEFAULT 'Luso Films',\n    did       integer DEFAULT nextval('distributors_serial'),\n    modtime   timestamp DEFAULT current_timestamp\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer CONSTRAINT no_null NOT NULL,\n    name    varchar(40) NOT NULL\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer,\n    name    varchar(40) UNIQUE\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    UNIQUE(name)\n);"
  },
  {
    "Query": "CREATE TABLE distributors (\n    did     integer,\n    name    varchar(40),\n    UNIQUE(name) WITH (fillfactor=70)\n)\nWITH (fillfactor=70);"
  },
  {
    "Query": "CREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);"
  },
  {
    "Query": "CREATE TABLE cinemas (\n        id serial,\n        name text,\n        location text\n) TABLESPACE diskvol1;"
  },
  {
    "Query": "CREATE TYPE employee_type AS (name text, salary numeric);"
  },
  {
    "Query": "CREATE TABLE employees OF employee_type (\n    PRIMARY KEY (name),\n    salary WITH OPTIONS DEFAULT 1000\n);"
  },
  {
    "Query": "CREATE TABLE measurement (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (logdate);"
  },
  {
    "Query": "CREATE TABLE measurement_year_month (\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (EXTRACT(YEAR FROM logdate), EXTRACT(MONTH FROM logdate));"
  },
  {
    "Query": "CREATE TABLE cities (\n    city_id      bigserial not null,\n    name         text not null,\n    population   bigint\n) PARTITION BY LIST (left(lower(name), 1));"
  },
  {
    "Query": "CREATE TABLE orders (\n    order_id     bigint not null,\n    cust_id      bigint not null,\n    status       text\n) PARTITION BY HASH (order_id);"
  },
  {
    "Query": "CREATE TABLE measurement_y2016m07\n    PARTITION OF measurement (\n    unitsales DEFAULT 0\n) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');"
  },
  {
    "Query": "CREATE TABLE measurement_ym_older\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (MINVALUE, MINVALUE) TO (2016, 11);"
  },
  {
    "Query": "CREATE TABLE measurement_ym_y2016m11\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2016, 11) TO (2016, 12);"
  },
  {
    "Query": "CREATE TABLE measurement_ym_y2016m12\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2016, 12) TO (2017, 01);"
  },
  {
    "Query": "CREATE TABLE measurement_ym_y2017m01\n    PARTITION OF measurement_year_month\n    FOR VALUES FROM (2017, 01) TO (2017, 02);"
  },
  {
    "Query": "CREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b');"
  },
  {
    "Query": "CREATE TABLE cities_ab\n    PARTITION OF cities (\n    CONSTRAINT city_id_nonzero CHECK (city_id != 0)\n) FOR VALUES IN ('a', 'b') PARTITION BY RANGE (population);"
  },
  {
    "Query": "CREATE TABLE cities_ab_10000_to_100000\n    PARTITION OF cities_ab FOR VALUES FROM (10000) TO (100000);"
  },
  {
    "Query": "CREATE TABLE orders_p1 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 0);"
  },
  {
    "Query": "CREATE TABLE orders_p2 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 1);"
  },
  {
    "Query": "CREATE TABLE orders_p3 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 2);"
  },
  {
    "Query": "CREATE TABLE orders_p4 PARTITION OF orders\n    FOR VALUES WITH (MODULUS 4, REMAINDER 3);"
  },
  {
    "Query": "CREATE TABLE cities_partdef\n    PARTITION OF cities DEFAULT;"
  },
  {
    "Query": "UPDATE tt SET ti =\n    setweight(to_tsvector(coalesce(title,'')), 'A')    ||\n    setweight(to_tsvector(coalesce(keyword,'')), 'B')  ||\n    setweight(to_tsvector(coalesce(abstract,'')), 'C') ||\n    setweight(to_tsvector(coalesce(body,'')), 'D');"
  },
  {
    "Query": "CREATE SERVER myserver FOREIGN DATA WRAPPER postgres_fdw OPTIONS (host 'foo', dbname 'foodb', port '5432');"
  },
  {
    "Query": "DROP MATERIALIZED VIEW order_summary;"
  },
  {
    "Query": "DROP TABLESPACE mystuff;"
  },
  {
    "Query": "DROP AGGREGATE myavg(integer);"
  },
  {
    "Query": "DROP AGGREGATE myrank(VARIADIC \"any\" ORDER BY VARIADIC \"any\");"
  },
  {
    "Query": "DROP AGGREGATE myavg(integer), myavg(bigint);"
  },
  {
    "Query": "LISTEN virtual;"
  },
  {
    "Query": "NOTIFY virtual;"
  },
  {
    "Query": "CALL do_db_maintenance();"
  },
  {
    "Query": "SELECT x, y FROM tab WHERE x = 'key';"
  },
  {
    "Query": "SELECT x FROM tab WHERE x = 'key' AND y < 42;"
  },
  {
    "Query": "SELECT x, z FROM tab WHERE x = 'key';"
  },
  {
    "Query": "SELECT x FROM tab WHERE x = 'key' AND z < 42;"
  },
  {
    "Query": "SELECT y FROM tab WHERE x = 'key';"
  },
  {
    "Query": "CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);"
  },
  {
    "Query": "CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);"
  },
  {
    "Query": "CREATE INDEX tab_x_y ON tab(x, y);"
  },
  {
    "Query": "SELECT f(x) FROM tab WHERE f(x) < 1;"
  },
  {
    "Query": "CREATE INDEX tab_f_x ON tab (f(x)) INCLUDE (x);"
  },
  {
    "Query": "CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n    WHERE success;"
  },
  {
    "Query": "SELECT target FROM tests WHERE subject = 'some-subject' AND success;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION tclsnitch() RETURNS event_trigger AS $$\n  elog NOTICE \"tclsnitch: $TG_event $TG_tag\"\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE EVENT TRIGGER tcl_a_snitch ON ddl_command_start EXECUTE FUNCTION tclsnitch();"
  },
  {
    "Query": "LISTEN virtual;"
  },
  {
    "Query": "NOTIFY virtual;"
  },
  {
    "Query": "UNLISTEN virtual;"
  },
  {
    "Query": "NOTIFY virtual;"
  },
  {
    "Query": "SELECT * FROM pg_locks pl LEFT JOIN pg_stat_activity psa\n    ON pl.pid = psa.pid;"
  },
  {
    "Query": "SELECT * FROM pg_locks pl LEFT JOIN pg_prepared_xacts ppx\n    ON pl.virtualtransaction = '-1/' || ppx.transaction;"
  },
  {
    "Query": "CREATE TABLE test1 (a character(4));"
  },
  {
    "Query": "INSERT INTO test1 VALUES ('ok');"
  },
  {
    "Query": "SELECT a, char_length(a) FROM test1;"
  },
  {
    "Query": "CREATE TABLE test2 (b varchar(5))"
  },
  {
    "Query": "INSERT INTO test2 VALUES ('ok');"
  },
  {
    "Query": "INSERT INTO test2 VALUES ('good      ');"
  },
  {
    "Query": "INSERT INTO test2 VALUES ('too long');"
  },
  {
    "Query": "INSERT INTO test2 VALUES ('too long'::varchar(5))"
  },
  {
    "Query": "SELECT b, char_length(b) FROM test2;"
  },
  {
    "Query": "CREATE TABLE capitals (\n  name       text,\n  population real,\n  elevation  int,\nstate      char(2)\n);"
  },
  {
    "Query": "CREATE TABLE non_capitals (\n  name       text,\n  population real,\n  elevation  int\n);"
  },
  {
    "Query": "CREATE VIEW cities AS\n  SELECT name, population, elevation FROM capitals\n    UNION\n  SELECT name, population, elevation FROM non_capitals;"
  },
  {
    "Query": "CREATE TABLE cities (\n  name       text,\n  population real,\n  elevation  int\n);"
  },
  {
    "Query": "CREATE TABLE capitals (\n  state      char(2) UNIQUE NOT NULL\n) INHERITS (cities);"
  },
  {
    "Query": "SELECT name, elevation\n  FROM cities\n  WHERE elevation > 500;"
  },
  {
    "Query": "SELECT name, elevation\n    FROM ONLY cities\n    WHERE elevation > 500;"
  },
  {
    "Query": "IMPORT FOREIGN SCHEMA foreign_films\n    FROM SERVER film_server INTO films"
  },
  {
    "Query": "IMPORT FOREIGN SCHEMA foreign_films LIMIT TO (actors, directors)\n    FROM SERVER film_server INTO films"
  },
  {
    "Query": "DROP DOMAIN box;"
  },
  {
    "Query": "SELECT pg_start_backup('label', false, false);"
  },
  {
    "Query": "SELECT * FROM pg_stop_backup(false, true);"
  },
  {
    "Query": "SELECT pg_start_backup('label');"
  },
  {
    "Query": "SELECT pg_start_backup('label', true);"
  },
  {
    "Query": "SELECT pg_stop_backup();"
  },
  {
    "Query": "ALTER TABLE table_name OWNER TO new_owner;"
  },
  {
    "Query": "GRANT UPDATE ON accounts TO joe;"
  },
  {
    "Query": "REVOKE ALL ON accounts FROM PUBLIC;"
  },
  {
    "Query": "GRANT SELECT ON mytable TO PUBLIC;"
  },
  {
    "Query": "GRANT SELECT, UPDATE, INSERT ON mytable TO admin;"
  },
  {
    "Query": "GRANT SELECT (col1), UPDATE (col1) ON mytable TO miriam_rw;"
  },
  {
    "Query": "CREATE SCHEMA myschema;"
  },
  {
    "Query": "CREATE SCHEMA AUTHORIZATION joe;"
  },
  {
    "Query": "CREATE SCHEMA IF NOT EXISTS test AUTHORIZATION joe;"
  },
  {
    "Query": "CREATE SCHEMA hollywood\n    CREATE TABLE films (title text, release date, awards text[])\n    CREATE VIEW winners AS\n        SELECT title, release FROM films WHERE awards IS NOT NULL;"
  },
  {
    "Query": "CREATE SCHEMA hollywood;"
  },
  {
    "Query": "CREATE TABLE hollywood.films (title text, release date, awards text[]);"
  },
  {
    "Query": "CREATE VIEW hollywood.winners AS\n    SELECT title, release FROM hollywood.films WHERE awards IS NOT NULL;"
  },
  {
    "Query": "CREATE TABLE measurement (\n    city_id         int not null,\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n);"
  },
  {
    "Query": "CREATE TABLE measurement (\n    city_id         int not null,\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n) PARTITION BY RANGE (logdate);"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m02 PARTITION OF measurement\n    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m03 PARTITION OF measurement\n    FOR VALUES FROM ('2006-03-01') TO ('2006-04-01');"
  },
  {
    "Query": "CREATE TABLE measurement_y2007m11 PARTITION OF measurement\n    FOR VALUES FROM ('2007-11-01') TO ('2007-12-01')"
  },
  {
    "Query": "CREATE TABLE measurement_y2007m12 PARTITION OF measurement\n    FOR VALUES FROM ('2007-12-01') TO ('2008-01-01')\n    TABLESPACE fasttablespace;"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m01 PARTITION OF measurement\n    FOR VALUES FROM ('2008-01-01') TO ('2008-02-01')\n    WITH (parallel_workers = 4)\n    TABLESPACE fasttablespace;"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m02 PARTITION OF measurement\n    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01')\n    PARTITION BY RANGE (peaktemp);"
  },
  {
    "Query": "CREATE INDEX ON measurement (logdate);"
  },
  {
    "Query": "DROP TABLE measurement_y2006m02;"
  },
  {
    "Query": "ALTER TABLE measurement DETACH PARTITION measurement_y2006m02;"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m02 PARTITION OF measurement\n    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01')\n    TABLESPACE fasttablespace;"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m02\n  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS)\n  TABLESPACE fasttablespace;"
  },
  {
    "Query": "ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02\n   CHECK ( logdate >= DATE '2008-02-01' AND logdate < DATE '2008-03-01' );"
  },
  {
    "Query": "ALTER TABLE measurement ATTACH PARTITION measurement_y2008m02\n    FOR VALUES FROM ('2008-02-01') TO ('2008-03-01' )"
  },
  {
    "Query": "CREATE INDEX measurement_usls_idx ON ONLY measurement (unitsales);"
  },
  {
    "Query": "CREATE INDEX measurement_usls_200602_idx\n    ON measurement_y2006m02 (unitsales);"
  },
  {
    "Query": "ALTER INDEX measurement_usls_idx\n    ATTACH PARTITION measurement_usls_200602_idx;"
  },
  {
    "Query": "ALTER TABLE ONLY measurement ADD UNIQUE (city_id, logdate);"
  },
  {
    "Query": "ALTER TABLE measurement_y2006m02 ADD UNIQUE (city_id, logdate);"
  },
  {
    "Query": "ALTER INDEX measurement_city_id_logdate_key\n    ATTACH PARTITION measurement_y2006m02_city_id_logdate_key;"
  },
  {
    "Query": "CREATE TABLE measurement (\n    city_id         int not null,\n    logdate         date not null,\n    peaktemp        int,\n    unitsales       int\n);"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m02 () INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m03 () INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2007m11 () INHERITS (measurement)"
  },
  {
    "Query": "CREATE TABLE measurement_y2007m12 () INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m01 () INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m02 (\n    CHECK ( logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01' )\n) INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2006m03 (\n    CHECK ( logdate >= DATE '2006-03-01' AND logdate < DATE '2006-04-01' )\n) INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2007m11 (\n    CHECK ( logdate >= DATE '2007-11-01' AND logdate < DATE '2007-12-01' )\n) INHERITS (measurement)"
  },
  {
    "Query": "CREATE TABLE measurement_y2007m12 (\n    CHECK ( logdate >= DATE '2007-12-01' AND logdate < DATE '2008-01-01' )\n) INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m01 (\n    CHECK ( logdate >= DATE '2008-01-01' AND logdate < DATE '2008-02-01' )\n) INHERITS (measurement);"
  },
  {
    "Query": "CREATE INDEX measurement_y2006m02_logdate ON measurement_y2006m02 (logdate);"
  },
  {
    "Query": "CREATE INDEX measurement_y2006m03_logdate ON measurement_y2006m03 (logdate);"
  },
  {
    "Query": "CREATE INDEX measurement_y2007m11_logdate ON measurement_y2007m11 (logdate);"
  },
  {
    "Query": "CREATE INDEX measurement_y2007m12_logdate ON measurement_y2007m12 (logdate);"
  },
  {
    "Query": "CREATE INDEX measurement_y2008m01_logdate ON measurement_y2008m01 (logdate);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION measurement_insert_trigger()\nRETURNS TRIGGER AS $$\nBEGIN\n    INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n    RETURN NULL;\nEND;\n$$\nLANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER insert_measurement_trigger\n    BEFORE INSERT ON measurement\n    FOR EACH ROW EXECUTE FUNCTION measurement_insert_trigger();"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION measurement_insert_trigger()\nRETURNS TRIGGER AS $$\nBEGIN\n    IF ( NEW.logdate >= DATE '2006-02-01' AND\n         NEW.logdate < DATE '2006-03-01' ) THEN\n        INSERT INTO measurement_y2006m02 VALUES (NEW.*);\n    ELSIF ( NEW.logdate >= DATE '2006-03-01' AND\n            NEW.logdate < DATE '2006-04-01' ) THEN\n        INSERT INTO measurement_y2006m03 VALUES (NEW.*);\n    ...\n    ELSIF ( NEW.logdate >= DATE '2008-01-01' AND\n            NEW.logdate < DATE '2008-02-01' ) THEN\n        INSERT INTO measurement_y2008m01 VALUES (NEW.*);\n    ELSE\n        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';\n    END IF;\n    RETURN NULL;\nEND;\n$$\nLANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE RULE measurement_insert_y2006m02 AS\nON INSERT TO measurement WHERE\n    ( logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01' )\nDO INSTEAD\n    INSERT INTO measurement_y2006m02 VALUES (NEW.*);"
  },
  {
    "Query": "CREATE RULE measurement_insert_y2008m01 AS\nON INSERT TO measurement WHERE\n    ( logdate >= DATE '2008-01-01' AND logdate < DATE '2008-02-01' )\nDO INSTEAD\n    INSERT INTO measurement_y2008m01 VALUES (NEW.*)"
  },
  {
    "Query": "DROP TABLE measurement_y2006m02;"
  },
  {
    "Query": "ALTER TABLE measurement_y2006m02 NO INHERIT measurement;"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m02 (\n    CHECK ( logdate >= DATE '2008-02-01' AND logdate < DATE '2008-03-01' )\n) INHERITS (measurement);"
  },
  {
    "Query": "CREATE TABLE measurement_y2008m02\n  (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);"
  },
  {
    "Query": "ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02\n   CHECK ( logdate >= DATE '2008-02-01' AND logdate < DATE '2008-03-01' );"
  },
  {
    "Query": "ALTER TABLE measurement_y2008m02 INHERIT measurement"
  },
  {
    "Query": "ANALYZE measurement;"
  },
  {
    "Query": "SET enable_partition_pruning = on;"
  },
  {
    "Query": "SELECT count(*) FROM measurement WHERE logdate >= DATE '2008-01-01';"
  },
  {
    "Query": "SET enable_partition_pruning = off;"
  },
  {
    "Query": "EXPLAIN SELECT count(*) FROM measurement WHERE logdate >= DATE '2008-01-01';"
  },
  {
    "Query": "SET enable_partition_pruning = on;"
  },
  {
    "Query": "EXPLAIN SELECT count(*) FROM measurement WHERE logdate >= DATE '2008-01-01';"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$\n          ....\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$\n          ....\n$PROC$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION foo() RETURNS integer AS '\n          ....\n' LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT * FROM users WHERE f_name='foobar';"
  },
  {
    "Query": "SET plpgsql.extra_warnings TO 'shadowed_variables';"
  },
  {
    "Query": "CREATE FUNCTION foo(f1 int) RETURNS int AS $$\nDECLARE\nf1 int;\nBEGIN\nRETURN f1;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SET plpgsql.extra_warnings TO 'strict_multi_assignment';"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION public.foo()\n RETURNS void\n LANGUAGE plpgsql\nAS $$\nDECLARE\n  x int;\n  y int;\nBEGIN\n  SELECT 1 INTO x, y;\n  SELECT 1, 2 INTO x, y;\n  SELECT 1, 2, 3 INTO x, y;\nEND;\n$$;"
  },
  {
    "Query": "SELECT foo();"
  },
  {
    "Query": "DROP TEXT SEARCH DICTIONARY english;"
  },
  {
    "Query": "SELECT relpages, reltuples FROM pg_class WHERE relname = 'tenk1';"
  },
  {
    "Query": "CREATE UNIQUE INDEX title_idx ON films (title);"
  },
  {
    "Query": "CREATE UNIQUE INDEX title_idx ON films (title) INCLUDE (director, rating);"
  },
  {
    "Query": "CREATE INDEX title_idx ON films (title) WITH (deduplicate_items = off);"
  },
  {
    "Query": "CREATE INDEX ON films ((lower(title)));"
  },
  {
    "Query": "CREATE INDEX title_idx_german ON films (title COLLATE \"de_DE\");"
  },
  {
    "Query": "CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);"
  },
  {
    "Query": "CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);"
  },
  {
    "Query": "CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);"
  },
  {
    "Query": "CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;"
  },
  {
    "Query": "CREATE INDEX pointloc\n    ON points USING gist (box(location,location));"
  },
  {
    "Query": "SELECT * FROM points\n    WHERE box(location,location) && '(0,0),(1,1)'::box;"
  },
  {
    "Query": "CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);"
  },
  {
    "Query": "ROLLBACK TO SAVEPOINT my_savepoint;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "DECLARE foo CURSOR FOR SELECT 1 UNION SELECT 2;"
  },
  {
    "Query": "SAVEPOINT foo;"
  },
  {
    "Query": "FETCH 1 FROM foo;"
  },
  {
    "Query": "ROLLBACK TO SAVEPOINT foo"
  },
  {
    "Query": "FETCH 1 FROM foo;"
  },
  {
    "Query": "COMMIT"
  },
  {
    "Query": "CREATE TABLE image (\n    name            text,\n    raster          oid\n);"
  },
  {
    "Query": "SELECT lo_creat(-1);"
  },
  {
    "Query": "SELECT lo_create(43213);"
  },
  {
    "Query": "SELECT lo_unlink(173454);"
  },
  {
    "Query": "INSERT INTO image (name, raster)\n    VALUES ('beautiful image', lo_import('/etc/motd'));"
  },
  {
    "Query": "INSERT INTO image (name, raster)\nVALUES ('beautiful image', lo_import('/etc/motd', 68583));"
  },
  {
    "Query": "SELECT lo_export(image.raster, '/tmp/motd') FROM image\n    WHERE name = 'beautiful image';"
  },
  {
    "Query": "SELECT '12.34'::float8::numeric::money;"
  },
  {
    "Query": "SELECT '52093.89'::money::numeric::float8;"
  },
  {
    "Query": "CREATE ACCESS METHOD heptree TYPE INDEX HANDLER heptree_handler;"
  },
  {
    "Query": "ALTER DOMAIN zipcode SET NOT NULL;"
  },
  {
    "Query": "ALTER DOMAIN zipcode DROP NOT NULL;"
  },
  {
    "Query": "ALTER DOMAIN zipcode ADD CONSTRAINT zipchk CHECK (char_length(VALUE) = 5);"
  },
  {
    "Query": "ALTER DOMAIN zipcode DROP CONSTRAINT zipchk;"
  },
  {
    "Query": "ALTER DOMAIN zipcode RENAME CONSTRAINT zipchk TO zip_check;"
  },
  {
    "Query": "ALTER DOMAIN zipcode SET SCHEMA customers;"
  },
  {
    "Query": "CREATE TABLE image (title text, raster lo);"
  },
  {
    "Query": "CREATE TRIGGER t_raster BEFORE UPDATE OR DELETE ON image\n    FOR EACH ROW EXECUTE FUNCTION lo_manage(raster);"
  },
  {
    "Query": "CREATE TABLE test (\n    i int,\n    v varchar\n);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION valid_id() RETURNS trigger AS $$\n    if (($_TD->{new}{i} >= 100) || ($_TD->{new}{i} <= 0)) {\n        return \"SKIP\";    # skip INSERT/UPDATE command\n    } elsif ($_TD->{new}{v} ne \"immortal\") {\n        $_TD->{new}{v} .= \"(modified by trigger)\";\n        return \"MODIFY\";  # modify row and execute INSERT/UPDATE command\n    } else {\n        return;           # execute INSERT/UPDATE command\n    }\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE TRIGGER test_valid_id_trig\n    BEFORE INSERT OR UPDATE ON test\n    FOR EACH ROW EXECUTE FUNCTION valid_id();"
  },
  {
    "Query": "GRANT INSERT ON films TO PUBLIC;"
  },
  {
    "Query": "GRANT ALL PRIVILEGES ON kinds TO manuel;"
  },
  {
    "Query": "GRANT admins TO joe;"
  },
  {
    "Query": "BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;"
  },
  {
    "Query": "SELECT pg_export_snapshot();"
  },
  {
    "Query": "BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;"
  },
  {
    "Query": "SET TRANSACTION SNAPSHOT '00000003-0000001B-1';"
  },
  {
    "Query": "SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),\n                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts';"
  },
  {
    "Query": "ALTER GROUP staff ADD USER karl, john;"
  },
  {
    "Query": "ALTER GROUP workers DROP USER beth;"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION english\n    ALTER MAPPING FOR int, uint WITH intdict;"
  },
  {
    "Query": "ALTER TEXT SEARCH DICTIONARY unaccent (RULES='my_rules');"
  },
  {
    "Query": "select ts_lexize('unaccent','HÃ´tel');"
  },
  {
    "Query": "CREATE TEXT SEARCH CONFIGURATION fr ( COPY = french );"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION fr\n        ALTER MAPPING FOR hword, hword_part, word\n        WITH unaccent, french_stem;"
  },
  {
    "Query": "select to_tsvector('fr','HÃ´tels de la Mer');"
  },
  {
    "Query": "SELECT unaccent('unaccent', 'HÃ´tel');"
  },
  {
    "Query": "SELECT unaccent('HÃ´tel');"
  },
  {
    "Query": "SELECT pg_relation_filepath(oid), relpages FROM pg_class WHERE relname = 'customer';"
  },
  {
    "Query": "SELECT relname, relpages\nFROM pg_class,\n     (SELECT reltoastrelid\n      FROM pg_class\n      WHERE relname = 'customer') AS ss\nWHERE oid = ss.reltoastrelid OR\n      oid = (SELECT indexrelid\n             FROM pg_index\n             WHERE indrelid = ss.reltoastrelid)\nORDER BY relname;"
  },
  {
    "Query": "SELECT c2.relname, c2.relpages\nFROM pg_class c, pg_class c2, pg_index i\nWHERE c.relname = 'customer' AND\n      c.oid = i.indrelid AND\n      c2.oid = i.indexrelid\nORDER BY c2.relname;"
  },
  {
    "Query": "SELECT relname, relpages\nFROM pg_class\nORDER BY relpages DESC;"
  },
  {
    "Query": "CREATE CONVERSION myconv FOR 'UTF8' TO 'LATIN1' FROM myfunc;"
  },
  {
    "Query": "SELECT * FROM crosstab('...') AS ct(row_name text, category_1 text, category_2 text);"
  },
  {
    "Query": "CREATE TABLE ct(id SERIAL, rowid TEXT, attribute TEXT, value TEXT);"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test1','att1','val1');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test1','att2','val2');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test1','att3','val3');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test1','att4','val4');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test2','att1','val5');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test2','att2','val6');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test2','att3','val7');"
  },
  {
    "Query": "INSERT INTO ct(rowid, attribute, value) VALUES('test2','att4','val8');"
  },
  {
    "Query": "SELECT *\nFROM crosstab(\n  'select rowid, attribute, value\n   from ct\n   where attribute = ''att2'' or attribute = ''att3''\n   order by 1,2')\nAS ct(row_name text, category_1 text, category_2 text, category_3 text);"
  },
  {
    "Query": "SELECT *\nFROM crosstab3(\n  'select rowid, attribute, value\n   from ct\n   where attribute = ''att2'' or attribute = ''att3''\n   order by 1,2');"
  },
  {
    "Query": "CREATE TYPE my_crosstab_float8_5_cols AS (\n    my_row_name text,\n    my_category_1 float8,\n    my_category_2 float8,\n    my_category_3 float8,\n    my_category_4 float8,\n    my_category_5 float8\n);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(text)\n    RETURNS setof my_crosstab_float8_5_cols\n    AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION crosstab_float8_5_cols(\n    IN text,\n    OUT my_row_name text,\n    OUT my_category_1 float8,\n    OUT my_category_2 float8,\n    OUT my_category_3 float8,\n    OUT my_category_4 float8,\n    OUT my_category_5 float8)\n  RETURNS setof record\n  AS '$libdir/tablefunc','crosstab' LANGUAGE C STABLE STRICT;"
  },
  {
    "Query": "SELECT row_name, extra_col, cat, value FROM foo ORDER BY 1;"
  },
  {
    "Query": "SELECT DISTINCT cat FROM foo ORDER BY 1;"
  },
  {
    "Query": "SELECT * FROM crosstab('...', '...')\n    AS ct(row_name text, extra text, cat1 text, cat2 text, cat3 text, cat4 text);"
  },
  {
    "Query": "create table sales(year int, month int, qty int);"
  },
  {
    "Query": "insert into sales values(2007, 1, 1000);"
  },
  {
    "Query": "insert into sales values(2007, 2, 1500);"
  },
  {
    "Query": "insert into sales values(2007, 7, 500);"
  },
  {
    "Query": "insert into sales values(2007, 11, 1500);"
  },
  {
    "Query": "insert into sales values(2007, 12, 2000);"
  },
  {
    "Query": "insert into sales values(2008, 1, 1000);"
  },
  {
    "Query": "select * from crosstab(\n  'select year, month, qty from sales order by 1',\n  'select m from generate_series(1,12) m'\n) as (\n  year int,\n  \"Jan\" int,\n  \"Feb\" int,\n  \"Mar\" int,\n  \"Apr\" int,\n  \"May\" int,\n  \"Jun\" int,\n  \"Jul\" int,\n  \"Aug\" int,\n  \"Sep\" int,\n  \"Oct\" int,\n  \"Nov\" int,\n  \"Dec\" int\n);"
  },
  {
    "Query": "CREATE TABLE cth(rowid text, rowdt timestamp, attribute text, val text);"
  },
  {
    "Query": "INSERT INTO cth VALUES('test1','01 March 2003','temperature','42');"
  },
  {
    "Query": "INSERT INTO cth VALUES('test1','01 March 2003','test_result','PASS');"
  },
  {
    "Query": "INSERT INTO cth VALUES('test1','01 March 2003','volts','2.6987');"
  },
  {
    "Query": "INSERT INTO cth VALUES('test2','02 March 2003','temperature','53');"
  },
  {
    "Query": "INSERT INTO cth VALUES('test2','02 March 2003','test_result','FAIL');"
  },
  {
    "Query": "INSERT INTO cth VALUES('test2','02 March 2003','test_startdate','01 March 2003');"
  },
  {
    "Query": "INSERT INTO cth VALUES('test2','02 March 2003','volts','3.1234');"
  },
  {
    "Query": "SELECT * FROM crosstab\n(\n  'SELECT rowid, rowdt, attribute, val FROM cth ORDER BY 1',\n  'SELECT DISTINCT attribute FROM cth ORDER BY 1'\n)\nAS\n(\n       rowid text,\n       rowdt timestamp,\n       temperature int4,\n       test_result text,\n       test_startdate timestamp,\n       volts float8\n);"
  },
  {
    "Query": "SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')\n    AS t(keyid text, parent_keyid text, level int, branch text, pos int);"
  },
  {
    "Query": "CREATE TABLE connectby_tree(keyid text, parent_keyid text, pos int);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row1',NULL, 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row2','row1', 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row3','row1', 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row4','row2', 1);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row5','row2', 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row6','row4', 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row7','row3', 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row8','row6', 0);"
  },
  {
    "Query": "INSERT INTO connectby_tree VALUES('row9','row5', 0);"
  },
  {
    "Query": "SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0, '~')\n AS t(keyid text, parent_keyid text, level int, branch text);"
  },
  {
    "Query": "SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'row2', 0)\n AS t(keyid text, parent_keyid text, level int)"
  },
  {
    "Query": "SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0, '~')\n AS t(keyid text, parent_keyid text, level int, branch text, pos int)"
  },
  {
    "Query": "SELECT * FROM connectby('connectby_tree', 'keyid', 'parent_keyid', 'pos', 'row2', 0)\n AS t(keyid text, parent_keyid text, level int, pos int)"
  },
  {
    "Query": "SELECT setval('myseq', 42);"
  },
  {
    "Query": "SELECT setval('myseq', 42, true)"
  },
  {
    "Query": "SELECT setval('myseq', 42, false)"
  },
  {
    "Query": "CREATE TABLESPACE fastspace LOCATION '/ssd1/postgresql/data';"
  },
  {
    "Query": "CREATE TABLE foo(i int) TABLESPACE space1;"
  },
  {
    "Query": "SET default_tablespace = space1;"
  },
  {
    "Query": "CREATE TABLE foo(i int);"
  },
  {
    "Query": "CREATE TYPE dblink_pkey_results AS (position int, colname text);"
  },
  {
    "Query": "CREATE TABLE computer (\n    hostname        text,\nmanufacturer    text\n);"
  },
  {
    "Query": "CREATE TABLE software (\n    software        text,\nhostname        text\n);"
  },
  {
    "Query": "DELETE FROM software WHERE hostname = $1;"
  },
  {
    "Query": "CREATE RULE computer_del AS ON DELETE TO computer\n    DO DELETE FROM software WHERE hostname = OLD.hostname;"
  },
  {
    "Query": "DELETE FROM computer WHERE hostname = 'mypc.local.net';"
  },
  {
    "Query": "DELETE FROM software WHERE computer.hostname = 'mypc.local.net'\n                       AND software.hostname = computer.hostname;"
  },
  {
    "Query": "DELETE FROM computer WHERE hostname >= 'old'\n                       AND hostname <  'ole'"
  },
  {
    "Query": "DELETE FROM software WHERE computer.hostname >= 'old' AND computer.hostname < 'ole'\n                       AND software.hostname = computer.hostname;"
  },
  {
    "Query": "DELETE FROM computer WHERE hostname ~ '^old';"
  },
  {
    "Query": "DELETE FROM computer WHERE manufacturer = 'bim';"
  },
  {
    "Query": "DELETE FROM software WHERE computer.manufacturer = 'bim'\n                       AND software.hostname = computer.hostname;"
  },
  {
    "Query": "DROP CAST (text AS int);"
  },
  {
    "Query": "CREATE TRIGGER z_min_update\nBEFORE UPDATE ON tablename\nFOR EACH ROW EXECUTE FUNCTION suppress_redundant_updates_trigger();"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "SELECT DISTINCT ON (location) location, time, report\n    FROM weather_reports\n    ORDER BY location, time DESC;"
  },
  {
    "Query": "SELECT name FROM distributors ORDER BY code;"
  },
  {
    "Query": "SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "SELECT * FROM mytable WHERE key = 1 FOR UPDATE;"
  },
  {
    "Query": "SAVEPOINT s;"
  },
  {
    "Query": "ROLLBACK TO s;"
  },
  {
    "Query": "SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;"
  },
  {
    "Query": "TABLE name"
  },
  {
    "Query": "SELECT * FROM name"
  },
  {
    "Query": "SELECT f.title, f.did, d.name, f.date_prod, f.kind\n    FROM distributors d JOIN films f USING (did);"
  },
  {
    "Query": "SELECT kind, sum(len) AS total FROM films GROUP BY kind;"
  },
  {
    "Query": "SELECT kind, sum(len) AS total\n    FROM films\n    GROUP BY kind\n    HAVING sum(len) < interval '5 hours';"
  },
  {
    "Query": "SELECT * FROM distributors ORDER BY name;"
  },
  {
    "Query": "SELECT * FROM distributors ORDER BY 2;"
  },
  {
    "Query": "SELECT distributors.name\n    FROM distributors\n    WHERE distributors.name LIKE 'W%'\nUNION\nSELECT actors.name\n    FROM actors\n    WHERE actors.name LIKE 'W%'"
  },
  {
    "Query": "CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$\n    SELECT * FROM distributors WHERE did = $1;\n$$ LANGUAGE SQL;"
  },
  {
    "Query": "SELECT * FROM distributors(111);"
  },
  {
    "Query": "CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$\n    SELECT * FROM distributors WHERE did = $1"
  },
  {
    "Query": "SELECT * FROM distributors_2(111) AS (f1 int, f2 text);"
  },
  {
    "Query": "SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;"
  },
  {
    "Query": "WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (\n    SELECT 1, employee_name, manager_name\n    FROM employee\n    WHERE manager_name = 'Mary'\n  UNION ALL\n    SELECT er.distance + 1, e.employee_name, e.manager_name\n    FROM employee_recursive er, employee e\n    WHERE er.employee_name = e.manager_name\n  )\nSELECT distance, employee_name FROM employee_recursive"
  },
  {
    "Query": "SELECT m.name AS mname, pname\nFROM manufacturers m, LATERAL get_product_names(m.id) pname;"
  },
  {
    "Query": "SELECT m.name AS mname, pname\nFROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;"
  },
  {
    "Query": "SELECT 2+2;"
  },
  {
    "Query": "SELECT distributors.* WHERE distributors.name = 'Westward';"
  },
  {
    "Query": "BEGIN WORK;"
  },
  {
    "Query": "DECLARE liahona CURSOR FOR SELECT * FROM films;"
  },
  {
    "Query": "MOVE FORWARD 5 IN liahona;"
  },
  {
    "Query": "FETCH 1 FROM liahona"
  },
  {
    "Query": "CLOSE liahona"
  },
  {
    "Query": "COMMIT WORK;"
  },
  {
    "Query": "CREATE EXTENSION hstore SCHEMA addons;"
  },
  {
    "Query": "SET search_path = addons;"
  },
  {
    "Query": "CREATE EXTENSION hstore;"
  },
  {
    "Query": "BEGIN WORK;"
  },
  {
    "Query": "DECLARE liahona SCROLL CURSOR FOR SELECT * FROM films;"
  },
  {
    "Query": "FETCH FORWARD 5 FROM liahona;"
  },
  {
    "Query": "FETCH PRIOR FROM liahona"
  },
  {
    "Query": "CLOSE liahona"
  },
  {
    "Query": "COMMIT WORK;"
  },
  {
    "Query": "CREATE TABLE sal_emp (\n    name            text,\n    pay_by_quarter  integer[],\n    schedule        text[][]\n);"
  },
  {
    "Query": "CREATE TABLE tictactoe (\n    squares   integer[3][3]\n);"
  },
  {
    "Query": "INSERT INTO sal_emp\n    VALUES ('Bill',\n    '{10000, 10000, 10000, 10000}',\n    '{{\"meeting\", \"lunch\"}, {\"training\", \"presentation\"}}');"
  },
  {
    "Query": "INSERT INTO sal_emp\n    VALUES ('Carol',\n    '{20000, 25000, 25000, 25000}',\n    '{{\"breakfast\", \"consulting\"}, {\"meeting\", \"lunch\"}}');"
  },
  {
    "Query": "SELECT * FROM sal_emp;"
  },
  {
    "Query": "INSERT INTO sal_emp\n    VALUES ('Bill',\n    '{10000, 10000, 10000, 10000}',\n    '{{\"meeting\", \"lunch\"}, {\"meeting\"}}');"
  },
  {
    "Query": "INSERT INTO sal_emp\n    VALUES ('Bill',\n    ARRAY[10000, 10000, 10000, 10000],\n    ARRAY[['meeting', 'lunch'], ['training', 'presentation']]);"
  },
  {
    "Query": "INSERT INTO sal_emp\n    VALUES ('Carol',\n    ARRAY[20000, 25000, 25000, 25000],\n    ARRAY[['breakfast', 'consulting'], ['meeting', 'lunch']]);"
  },
  {
    "Query": "SELECT name FROM sal_emp WHERE pay_by_quarter[1] <> pay_by_quarter[2];"
  },
  {
    "Query": "SELECT pay_by_quarter[3] FROM sal_emp;"
  },
  {
    "Query": "SELECT schedule[1:2][1:1] FROM sal_emp WHERE name = 'Bill';"
  },
  {
    "Query": "SELECT schedule[1:2][2] FROM sal_emp WHERE name = 'Bill';"
  },
  {
    "Query": "SELECT schedule[:2][2:] FROM sal_emp WHERE name = 'Bill';"
  },
  {
    "Query": "SELECT schedule[:][1:1] FROM sal_emp WHERE name = 'Bill'"
  },
  {
    "Query": "SELECT array_dims(schedule) FROM sal_emp WHERE name = 'Carol';"
  },
  {
    "Query": "SELECT array_upper(schedule, 1) FROM sal_emp WHERE name = 'Carol';"
  },
  {
    "Query": "SELECT array_length(schedule, 1) FROM sal_emp WHERE name = 'Carol';"
  },
  {
    "Query": "SELECT cardinality(schedule) FROM sal_emp WHERE name = 'Carol';"
  },
  {
    "Query": "UPDATE sal_emp SET pay_by_quarter = '{25000,25000,27000,27000}'\n    WHERE name = 'Carol';"
  },
  {
    "Query": "UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000]\n    WHERE name = 'Carol';"
  },
  {
    "Query": "UPDATE sal_emp SET pay_by_quarter[4] = 15000\n    WHERE name = 'Bill';"
  },
  {
    "Query": "UPDATE sal_emp SET pay_by_quarter[1:2] = '{27000,27000}'\n    WHERE name = 'Carol';"
  },
  {
    "Query": "SELECT ARRAY[1,2] || ARRAY[3,4];"
  },
  {
    "Query": "SELECT ARRAY[5,6] || ARRAY[[1,2],[3,4]]"
  },
  {
    "Query": "SELECT array_dims(1 || '[0:1]={2,3}'::int[]);"
  },
  {
    "Query": "SELECT array_dims(ARRAY[1,2] || 3)"
  },
  {
    "Query": "SELECT array_dims(ARRAY[1,2] || ARRAY[3,4,5]);"
  },
  {
    "Query": "SELECT array_dims(ARRAY[[1,2],[3,4]] || ARRAY[[5,6],[7,8],[9,0]])"
  },
  {
    "Query": "SELECT array_dims(ARRAY[1,2] || ARRAY[[3,4],[5,6]]);"
  },
  {
    "Query": "SELECT array_prepend(1, ARRAY[2,3]);"
  },
  {
    "Query": "SELECT array_append(ARRAY[1,2], 3)"
  },
  {
    "Query": "SELECT array_cat(ARRAY[1,2], ARRAY[3,4])"
  },
  {
    "Query": "SELECT array_cat(ARRAY[[1,2],[3,4]], ARRAY[5,6])"
  },
  {
    "Query": "SELECT array_cat(ARRAY[5,6], ARRAY[[1,2],[3,4]])"
  },
  {
    "Query": "SELECT ARRAY[1, 2] || '{3, 4}';"
  },
  {
    "Query": "SELECT ARRAY[1, 2] || '7'"
  },
  {
    "Query": "SELECT ARRAY[1, 2] || NULL"
  },
  {
    "Query": "SELECT array_append(ARRAY[1, 2], NULL)"
  },
  {
    "Query": "SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR\n                            pay_by_quarter[2] = 10000 OR\n                            pay_by_quarter[3] = 10000 OR\n                            pay_by_quarter[4] = 10000;"
  },
  {
    "Query": "SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter);"
  },
  {
    "Query": "SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter);"
  },
  {
    "Query": "SELECT * FROM\n   (SELECT pay_by_quarter,\n           generate_subscripts(pay_by_quarter, 1) AS s\n      FROM sal_emp) AS foo\n WHERE pay_by_quarter[s] = 10000;"
  },
  {
    "Query": "SELECT * FROM sal_emp WHERE pay_by_quarter && ARRAY[10000];"
  },
  {
    "Query": "SELECT array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon');"
  },
  {
    "Query": "SELECT array_positions(ARRAY[1, 4, 3, 1, 3, 4, 2, 1], 1)"
  },
  {
    "Query": "SELECT f1[1][-2][3] AS e1, f1[1][-1][5] AS e2\n FROM (SELECT '[1:1][-2:-1][3:5]={{{1,2,3},{4,5,6}}}'::int[] AS f1) AS ss;"
  },
  {
    "Query": "CREATE FOREIGN DATA WRAPPER dummy;"
  },
  {
    "Query": "CREATE FOREIGN DATA WRAPPER file HANDLER file_fdw_handler;"
  },
  {
    "Query": "CREATE FOREIGN DATA WRAPPER mywrapper\n    OPTIONS (debug 'true');"
  },
  {
    "Query": "CREATE EXTENSION plpythonu;"
  },
  {
    "Query": "CREATE TRANSFORM FOR hstore LANGUAGE plpythonu (\n    FROM SQL WITH FUNCTION hstore_to_plpython(internal),\n    TO SQL WITH FUNCTION plpython_to_hstore(internal)\n);"
  },
  {
    "Query": "DROP ROUTINE foo(integer);"
  },
  {
    "Query": "DROP TRANSFORM FOR hstore LANGUAGE plpythonu;"
  },
  {
    "Query": "DROP TABLE films, distributors;"
  },
  {
    "Query": "INSERT INTO mytable VALUES(1);"
  },
  {
    "Query": "SELECT 1/0;"
  },
  {
    "Query": "INSERT INTO mytable VALUES(2);"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "INSERT INTO mytable VALUES(1);"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "INSERT INTO mytable VALUES(2);"
  },
  {
    "Query": "SELECT 1/0;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "SELECT 1/0;"
  },
  {
    "Query": "ROLLBACK;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "INSERT INTO mytable VALUES(1);"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "INSERT INTO mytable VALUES(2);"
  },
  {
    "Query": "DROP EVENT TRIGGER snitch;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,\n                                                  v_version varchar)\nRETURNS varchar AS $$\nBEGIN\n    IF v_version IS NULL THEN\n        RETURN v_name;\n    END IF;\n    RETURN v_name || '/' || v_version;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "FOR referrer_key IN referrer_keys LOOP\n        func_cmd := func_cmd ||\n          ' IF v_' || referrer_key.kind\n          || ' LIKE ''' || referrer_key.key_string\n          || ''' THEN RETURN ''' || referrer_key.referrer_type\n          || '''"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc() AS $func$\nDECLARE\n    referrer_keys CURSOR IS\n        SELECT * FROM cs_referrer_keys\n        ORDER BY try_order;\n    func_body text;\n    func_cmd text;\nBEGIN\n    func_body := 'BEGIN';\n\n    FOR referrer_key IN referrer_keys LOOP\n        func_body := func_body ||\n          ' IF v_' || referrer_key.kind\n          || ' LIKE ' || quote_literal(referrer_key.key_string)\n          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)\n          || '; END IF;' ;\n    END LOOP;\n\n    func_body := func_body || ' RETURN NULL; END;';\n\n    func_cmd :=\n      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,\n                                                        v_domain varchar,\n                                                        v_url varchar)\n        RETURNS varchar AS '\n      || quote_literal(func_body)\n      || ' LANGUAGE plpgsql;' ;\n\n    EXECUTE func_cmd;\nEND;\n$func$ LANGUAGE plpgsql;"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION cs_parse_url(\n    v_url IN VARCHAR,\n    v_host OUT VARCHAR,\nv_path OUT VARCHAR,\nv_query OUT VARCHAR) AS $$\nDECLARE\n    a_pos1 INTEGER;\n    a_pos2 INTEGER;\nBEGIN\n    v_host := NULL;\n    v_path := NULL;\n    v_query := NULL;\n    a_pos1 := instr(v_url, '//');\n\n    IF a_pos1 = 0 THEN\n        RETURN;\n    END IF;\n    a_pos2 := instr(v_url, '/', a_pos1 + 2);\n    IF a_pos2 = 0 THEN\n        v_host := substr(v_url, a_pos1 + 2);\n        v_path := '/';\n        RETURN;\n    END IF;\n\n    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);\n    a_pos1 := instr(v_url, '?', a_pos2 + 1);\n\n    IF a_pos1 = 0 THEN\n        v_path := substr(v_url, a_pos2);\n        RETURN;\n    END IF;\n\n    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);\n    v_query := substr(v_url, a_pos1 + 1);\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');"
  },
  {
    "Query": "SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;"
  },
  {
    "Query": "DELETE FROM cs_active_job;"
  },
  {
    "Query": "INSERT INTO cs_active_job(job_id) VALUES (v_job_id);"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id integer) AS $$\nDECLARE\n    a_running_job_count integer;\nBEGIN\n    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;\n\n    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;\n\n    IF a_running_job_count > 0 THEN\n        COMMIT; -- free lock\n        RAISE EXCEPTION 'Unable to create a new job: a job is currently running'; -- (1)\n    END IF;\n\n    DELETE FROM cs_active_job;\n    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);\n\n    BEGIN\n        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());\n    EXCEPTION\n        WHEN unique_violation THEN -- (2)\n            -- don't worry if it already exists\n    END;\n    COMMIT;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "END"
  },
  {
    "Query": "CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$\nBEGIN\n    RETURN instr($1, $2, 1);\nEND;\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;"
  },
  {
    "Query": "CREATE FUNCTION instr(string varchar, string_to_search_for varchar,\n                      beg_index integer)\nRETURNS integer AS $$\nDECLARE\n    pos integer NOT NULL DEFAULT 0;\n    temp_str varchar;\n    beg integer;\n    length integer;\n    ss_length integer;\nBEGIN\n    IF beg_index > 0 THEN\n        temp_str := substring(string FROM beg_index);\n        pos := position(string_to_search_for IN temp_str);\n\n        IF pos = 0 THEN\n            RETURN 0;\n        ELSE\n            RETURN pos + beg_index - 1;\n        END IF;\n    ELSIF beg_index < 0 THEN\n        ss_length := char_length(string_to_search_for);\n        length := char_length(string);\n        beg := length + 1 + beg_index;\n\n        WHILE beg > 0 LOOP\n            temp_str := substring(string FROM beg FOR ss_length);\n            IF string_to_search_for = temp_str THEN\n                RETURN beg;\n            END IF;\n\n            beg := beg - 1;\n        END LOOP;\n\n        RETURN 0;\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;"
  },
  {
    "Query": "CREATE FUNCTION instr(string varchar, string_to_search_for varchar,\n                      beg_index integer, occur_index integer)\nRETURNS integer AS $$\nDECLARE\n    pos integer NOT NULL DEFAULT 0;\n    occur_number integer NOT NULL DEFAULT 0;\n    temp_str varchar;\n    beg integer;\n    i integer;\n    length integer;\n    ss_length integer;\nBEGIN\n    IF occur_index <= 0 THEN\n        RAISE 'argument ''%'' is out of range', occur_index\n          USING ERRCODE = '22003';\n    END IF;\n\n    IF beg_index > 0 THEN\n        beg := beg_index - 1;\n        FOR i IN 1..occur_index LOOP\n            temp_str := substring(string FROM beg + 1);\n            pos := position(string_to_search_for IN temp_str);\n            IF pos = 0 THEN\n                RETURN 0;\n            END IF;\n            beg := beg + pos;\n        END LOOP;\n\n        RETURN beg;\n    ELSIF beg_index < 0 THEN\n        ss_length := char_length(string_to_search_for);\n        length := char_length(string);\n        beg := length + 1 + beg_index;\n\n        WHILE beg > 0 LOOP\n            temp_str := substring(string FROM beg FOR ss_length);\n            IF string_to_search_for = temp_str THEN\n                occur_number := occur_number + 1;\n                IF occur_number = occur_index THEN\n                    RETURN beg;\n                END IF;\n            END IF;\n\n            beg := beg - 1;\n        END LOOP;\n\n        RETURN 0;\n    ELSE\n        RETURN 0;\n    END IF;\nEND;\n$$ LANGUAGE plpgsql STRICT IMMUTABLE;"
  },
  {
    "Query": "ALTER OPERATOR FAMILY integer_ops USING btree ADD\n\n\nOPERATOR 1 < (int4, int2) ,\n  OPERATOR 2 <= (int4, int2) ,\n  OPERATOR 3 = (int4, int2) ,\n  OPERATOR 4 >= (int4, int2) ,\n  OPERATOR 5 > (int4, int2) ,\n  FUNCTION 1 btint42cmp(int4, int2) ,\n\n\nOPERATOR 1 < (int2, int4) ,\n  OPERATOR 2 <= (int2, int4) ,\n  OPERATOR 3 = (int2, int4) ,\n  OPERATOR 4 >= (int2, int4) ,\n  OPERATOR 5 > (int2, int4) ,\n  FUNCTION 1 btint24cmp(int2, int4) ;"
  },
  {
    "Query": "ALTER OPERATOR FAMILY integer_ops USING btree DROP\n\n\nOPERATOR 1 (int4, int2) ,\n  OPERATOR 2 (int4, int2) ,\n  OPERATOR 3 (int4, int2) ,\n  OPERATOR 4 (int4, int2) ,\n  OPERATOR 5 (int4, int2) ,\n  FUNCTION 1 (int4, int2) ,\n\n\nOPERATOR 1 (int2, int4) ,\n  OPERATOR 2 (int2, int4) ,\n  OPERATOR 3 (int2, int4) ,\n  OPERATOR 4 (int2, int4) ,\n  OPERATOR 5 (int2, int4) ,\n  FUNCTION 1 (int2, int4) ;"
  },
  {
    "Query": "CREATE ROLE name LOGIN;"
  },
  {
    "Query": "CREATE USER name;"
  },
  {
    "Query": "ALTER ROLE myname SET enable_indexscan TO off;"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY my_russian (\n    template = snowball,\n    language = russian,\n    stopwords = myrussian\n);"
  },
  {
    "Query": "CREATE TABLE test_trgm (t text);"
  },
  {
    "Query": "CREATE INDEX trgm_idx ON test_trgm USING GIST (t gist_trgm_ops);"
  },
  {
    "Query": "CREATE INDEX trgm_idx ON test_trgm USING GIN (t gin_trgm_ops);"
  },
  {
    "Query": "CREATE INDEX trgm_idx ON test_trgm USING GIST (t gist_trgm_ops(siglen=32));"
  },
  {
    "Query": "SELECT t, similarity(t, 'word') AS sml\n  FROM test_trgm\n  WHERE t % 'word'\n  ORDER BY sml DESC, t;"
  },
  {
    "Query": "SELECT t, t <-> 'word' AS dist\n  FROM test_trgm\n  ORDER BY dist LIMIT 10;"
  },
  {
    "Query": "SELECT t, word_similarity('word', t) AS sml\n  FROM test_trgm\n  WHERE 'word' <% t\n  ORDER BY sml DESC, t;"
  },
  {
    "Query": "SELECT t, strict_word_similarity('word', t) AS sml\n  FROM test_trgm\n  WHERE 'word' <<% t\n  ORDER BY sml DESC, t;"
  },
  {
    "Query": "SELECT t, 'word' <<-> t AS dist\n  FROM test_trgm\n  ORDER BY dist LIMIT 10;"
  },
  {
    "Query": "SELECT t, 'word' <<<-> t AS dist\n  FROM test_trgm\n  ORDER BY dist LIMIT 10;"
  },
  {
    "Query": "SELECT * FROM test_trgm WHERE t LIKE '%foo%bar';"
  },
  {
    "Query": "SELECT * FROM test_trgm WHERE t ~ '(foo|bar)';"
  },
  {
    "Query": "CREATE TABLE words AS SELECT word FROM\n        ts_stat('SELECT to_tsvector(''simple'', bodytext) FROM documents');"
  },
  {
    "Query": "CREATE INDEX words_idx ON words USING GIN (word gin_trgm_ops);"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION my_config\n  ALTER MAPPING REPLACE english WITH swedish;"
  },
  {
    "Query": "INSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');"
  },
  {
    "Query": "INSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');"
  },
  {
    "Query": "INSERT INTO films VALUES\n    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');"
  },
  {
    "Query": "INSERT INTO films (code, title, did, date_prod, kind)\n    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');"
  },
  {
    "Query": "INSERT INTO films DEFAULT VALUES;"
  },
  {
    "Query": "INSERT INTO films (code, title, did, date_prod, kind) VALUES\n    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),\n    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');"
  },
  {
    "Query": "INSERT INTO films SELECT * FROM tmp_films WHERE date_prod < '2004-05-07';"
  },
  {
    "Query": "INSERT INTO tictactoe (game, board[1:3][1:3])\n    VALUES (1, '{{\" \",\" \",\" \"},{\" \",\" \",\" \"},{\" \",\" \",\" \"}}');"
  },
  {
    "Query": "INSERT INTO tictactoe (game, board)\n    VALUES (2, '{{X,\" \",\" \"},{\" \",O,\" \"},{\" \",X,\" \"}}');"
  },
  {
    "Query": "INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')\n   RETURNING did;"
  },
  {
    "Query": "WITH upd AS (\n  UPDATE employees SET sales_count = sales_count + 1 WHERE id =\n    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')\n    RETURNING *\n)\nINSERT INTO employees_log SELECT *, current_timestamp FROM upd;"
  },
  {
    "Query": "INSERT INTO distributors (did, dname)\n    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')\n    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;"
  },
  {
    "Query": "INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')\n    ON CONFLICT (did) DO NOTHING;"
  },
  {
    "Query": "INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')\n    ON CONFLICT (did) DO UPDATE\n    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'\n    WHERE d.zipcode <> '21201';"
  },
  {
    "Query": "INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')\n    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;"
  },
  {
    "Query": "INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')\n    ON CONFLICT (did) WHERE is_active DO NOTHING;"
  },
  {
    "Query": "CREATE SCHEMA myschema;"
  },
  {
    "Query": "DROP SCHEMA myschema;"
  },
  {
    "Query": "DROP SCHEMA myschema CASCADE;"
  },
  {
    "Query": "CREATE SCHEMA schema_name AUTHORIZATION user_name;"
  },
  {
    "Query": "SHOW search_path;"
  },
  {
    "Query": "SET search_path TO myschema,public;"
  },
  {
    "Query": "DROP TABLE mytable;"
  },
  {
    "Query": "SET search_path TO myschema;"
  },
  {
    "Query": "SELECT 3 OPERATOR(pg_catalog.+) 4;"
  },
  {
    "Query": "REVOKE CREATE ON SCHEMA public FROM PUBLIC;"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CONSTRAINT positive_price CHECK (price > 0)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0),\n    discounted_price numeric CHECK (discounted_price > 0),\n    CHECK (price > discounted_price)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    CHECK (price > 0),\n    discounted_price numeric,\n    CHECK (discounted_price > 0),\n    CHECK (price > discounted_price)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric CHECK (price > 0),\n    discounted_price numeric,\n    CHECK (discounted_price > 0 AND price > discounted_price)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    CHECK (price > 0),\n    discounted_price numeric,\n    CHECK (discounted_price > 0),\n    CONSTRAINT valid_discount CHECK (price > discounted_price)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer NOT NULL,\n    name text NOT NULL,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer NOT NULL,\n    name text NOT NULL,\n    price numeric NOT NULL CHECK (price > 0)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer NULL,\n    name text NULL,\n    price numeric NULL\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer UNIQUE,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric,\n    UNIQUE (product_no)\n);"
  },
  {
    "Query": "CREATE TABLE example (\n    a integer,\n    b integer,\n    c integer,\n    UNIQUE (a, c)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer CONSTRAINT must_be_different UNIQUE,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer UNIQUE NOT NULL,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE example (\n    a integer,\n    b integer,\n    c integer,\n    PRIMARY KEY (a, c)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    product_no integer REFERENCES products (product_no),\n    quantity integer\n);"
  },
  {
    "Query": "CREATE TABLE orders (\n    order_id integer PRIMARY KEY,\n    product_no integer REFERENCES products,\n    quantity integer\n);"
  },
  {
    "Query": "CREATE TABLE t1 (\n  a integer PRIMARY KEY,\n  b integer,\n  c integer,\n  FOREIGN KEY (b, c) REFERENCES other_table (c1, c2)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE order_items (\n    product_no integer REFERENCES products,\n    order_id integer REFERENCES orders,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer PRIMARY KEY,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "CREATE TABLE order_items (\n    product_no integer REFERENCES products ON DELETE RESTRICT,\n    order_id integer REFERENCES orders ON DELETE CASCADE,\n    quantity integer,\n    PRIMARY KEY (product_no, order_id)\n);"
  },
  {
    "Query": "CREATE TABLE circles (\n    c circle,\n    EXCLUDE USING gist (c WITH &&)\n);"
  },
  {
    "Query": "SELECT CURRENT_TIMESTAMP;"
  },
  {
    "Query": "SELECT now();"
  },
  {
    "Query": "SELECT TIMESTAMP 'now';"
  },
  {
    "Query": "SELECT pg_sleep(1.5);"
  },
  {
    "Query": "CREATE TABLE users (firstname text, lastname text, id serial primary key);"
  },
  {
    "Query": "INSERT INTO users (firstname, lastname) VALUES ('Joe', 'Cool') RETURNING id;"
  },
  {
    "Query": "UPDATE products SET price = price * 1.10\n  WHERE price <= 99.99\n  RETURNING name, price AS new_price;"
  },
  {
    "Query": "DELETE FROM products\n  WHERE obsoletion_date = 'today'\n  RETURNING *;"
  },
  {
    "Query": "ALTER USER MAPPING FOR some_non_superuser SERVER loopback_nopw\nOPTIONS (ADD password_required 'false');"
  },
  {
    "Query": "CREATE EXTENSION postgres_fdw;"
  },
  {
    "Query": "CREATE SERVER foreign_server\n        FOREIGN DATA WRAPPER postgres_fdw\n        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');"
  },
  {
    "Query": "CREATE USER MAPPING FOR local_user\n        SERVER foreign_server\n        OPTIONS (user 'foreign_user', password 'password');"
  },
  {
    "Query": "CREATE FOREIGN TABLE foreign_table (\n        id integer NOT NULL,\n        data text\n)\n        SERVER foreign_server\n        OPTIONS (schema_name 'some_schema', table_name 'some_table');"
  },
  {
    "Query": "DELETE FROM weather WHERE city = 'Hayward';"
  },
  {
    "Query": "SELECT * FROM weather;"
  },
  {
    "Query": "CREATE FUNCTION complex_add(complex, complex)\n    RETURNS complex\n    AS 'filename', 'complex_add'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE OPERATOR + (\n    leftarg = complex,\n    rightarg = complex,\n    function = complex_add,\n    commutator = +\n);"
  },
  {
    "Query": "DELETE FROM films USING producers\n  WHERE producer_id = producers.id AND producers.name = 'foo';"
  },
  {
    "Query": "DELETE FROM films\n  WHERE producer_id IN (SELECT id FROM producers WHERE name = 'foo');"
  },
  {
    "Query": "DELETE FROM films WHERE kind <> 'Musical';"
  },
  {
    "Query": "DELETE FROM films;"
  },
  {
    "Query": "DELETE FROM tasks WHERE status = 'DONE' RETURNING *;"
  },
  {
    "Query": "DELETE FROM tasks WHERE CURRENT OF c_tasks;"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_get_changes('test_slot', NULL, NULL, 'include-xids', '0');"
  },
  {
    "Query": "REINDEX INDEX my_index;"
  },
  {
    "Query": "REINDEX TABLE my_table;"
  },
  {
    "Query": "REINDEX DATABASE broken_db"
  },
  {
    "Query": "REINDEX TABLE CONCURRENTLY my_broken_table;"
  },
  {
    "Query": "ALTER OPERATOR @@ (text, text) OWNER TO joe;"
  },
  {
    "Query": "ALTER OPERATOR && (_int4, _int4) SET (RESTRICT = _int_contsel, JOIN = _int_contjoinsel);"
  },
  {
    "Query": "CREATE FUNCTION add_one(integer) RETURNS integer\n     AS 'DIRECTORY/funcs', 'add_one'\n     LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE FUNCTION add_one(double precision) RETURNS double precision\n     AS 'DIRECTORY/funcs', 'add_one_float8'\n     LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE FUNCTION makepoint(point, point) RETURNS point\n     AS 'DIRECTORY/funcs', 'makepoint'\n     LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE FUNCTION copytext(text) RETURNS text\n     AS 'DIRECTORY/funcs', 'copytext'\n     LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE FUNCTION concat_text(text, text) RETURNS text\n     AS 'DIRECTORY/funcs', 'concat_text'\n     LANGUAGE C STRICT;"
  },
  {
    "Query": "SELECT name, c_overpaid(emp, 1500) AS overpaid\n    FROM emp\n    WHERE name = 'Bill' OR name = 'Sam';"
  },
  {
    "Query": "CREATE FUNCTION c_overpaid(emp, integer) RETURNS boolean\n    AS 'DIRECTORY/funcs', 'c_overpaid'\n    LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE TYPE __retcomposite AS (f1 integer, f2 integer, f3 integer);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION retcomposite(integer, integer)\n    RETURNS SETOF __retcomposite\n    AS 'filename', 'retcomposite'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION retcomposite(IN integer, IN integer,\n    OUT f1 integer, OUT f2 integer, OUT f3 integer)\n    RETURNS SETOF record\n    AS 'filename', 'retcomposite'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE FUNCTION make_array(anyelement) RETURNS anyarray\n    AS 'DIRECTORY/funcs', 'make_array'\n    LANGUAGE C IMMUTABLE;"
  },
  {
    "Query": "CREATE FUNCTION dept(text) RETURNS dept\n    AS $$ SELECT * FROM dept WHERE name = $1 $$\n    LANGUAGE SQL;"
  },
  {
    "Query": "SELECT percentile_cont(0.5) WITHIN GROUP (ORDER BY income) FROM households;"
  },
  {
    "Query": "SELECT\n    count(*) AS unfiltered,\n    count(*) FILTER (WHERE i < 5) AS filtered\nFROM generate_series(1,10) AS s(i);"
  },
  {
    "Query": "SELECT * FROM tbl WHERE a > 'foo' COLLATE \"C\";"
  },
  {
    "Query": "SELECT * FROM tbl WHERE a COLLATE \"C\" > 'foo';"
  },
  {
    "Query": "SELECT * FROM tbl WHERE (a > 'foo') COLLATE \"C\";"
  },
  {
    "Query": "SELECT name, (SELECT max(pop) FROM cities WHERE cities.state = states.name)\n    FROM states;"
  },
  {
    "Query": "SELECT ARRAY[1,2,3+4];"
  },
  {
    "Query": "SELECT ARRAY[1,2,22.7]::integer[];"
  },
  {
    "Query": "SELECT ARRAY[ARRAY[1,2], ARRAY[3,4]];"
  },
  {
    "Query": "SELECT ARRAY[[1,2],[3,4]]"
  },
  {
    "Query": "CREATE TABLE arr(f1 int[], f2 int[]);"
  },
  {
    "Query": "INSERT INTO arr VALUES (ARRAY[[1,2],[3,4]], ARRAY[[5,6],[7,8]]);"
  },
  {
    "Query": "SELECT ARRAY[f1, f2, '{{9,10},{11,12}}'::int[]] FROM arr;"
  },
  {
    "Query": "SELECT ARRAY[]::integer[];"
  },
  {
    "Query": "SELECT ARRAY(SELECT oid FROM pg_proc WHERE proname LIKE 'bytea%');"
  },
  {
    "Query": "SELECT ARRAY(SELECT ARRAY[i, i*2] FROM generate_series(1,5) AS a(i))"
  },
  {
    "Query": "SELECT ROW(1,2.5,'this is a test');"
  },
  {
    "Query": "SELECT ROW(t.*, 42) FROM t;"
  },
  {
    "Query": "SELECT ROW(t.f1, t.f2, 42) FROM t;"
  },
  {
    "Query": "CREATE TABLE mytable(f1 int, f2 float, f3 text);"
  },
  {
    "Query": "CREATE FUNCTION getf1(mytable) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;"
  },
  {
    "Query": "SELECT getf1(ROW(1,2.5,'this is a test'));"
  },
  {
    "Query": "CREATE TYPE myrowtype AS (f1 int, f2 text, f3 numeric)"
  },
  {
    "Query": "CREATE FUNCTION getf1(myrowtype) RETURNS int AS 'SELECT $1.f1' LANGUAGE SQL;"
  },
  {
    "Query": "SELECT getf1(ROW(1,2.5,'this is a test'));"
  },
  {
    "Query": "SELECT getf1(ROW(1,2.5,'this is a test')::mytable)"
  },
  {
    "Query": "SELECT getf1(CAST(ROW(11,'this is a test',2.5) AS myrowtype))"
  },
  {
    "Query": "SELECT ROW(1,2.5,'this is a test') = ROW(1, 3, 'not the same');"
  },
  {
    "Query": "SELECT true OR somefunc();"
  },
  {
    "Query": "SELECT somefunc() OR true;"
  },
  {
    "Query": "SELECT CASE WHEN x > 0 THEN x ELSE 1/0 END FROM tab;"
  },
  {
    "Query": "SELECT CASE WHEN min(employees) > 0\n            THEN avg(expenses / employees)\n       END\n    FROM departments;"
  },
  {
    "Query": "CREATE DOMAIN posint AS integer CHECK (VALUE > 0);"
  },
  {
    "Query": "CREATE TABLE mytable (id posint);"
  },
  {
    "Query": "INSERT INTO mytable VALUES(1);"
  },
  {
    "Query": "INSERT INTO mytable VALUES(-1);"
  },
  {
    "Query": "ALTER INDEX distributors RENAME TO suppliers;"
  },
  {
    "Query": "ALTER INDEX distributors SET TABLESPACE fasttablespace;"
  },
  {
    "Query": "ALTER INDEX distributors SET (fillfactor = 75);"
  },
  {
    "Query": "REINDEX INDEX distributors;"
  },
  {
    "Query": "CREATE INDEX coord_idx ON measured (x, y, (z + t));"
  },
  {
    "Query": "ALTER INDEX coord_idx ALTER COLUMN 3 SET STATISTICS 1000;"
  },
  {
    "Query": "VALUES (1, 'one'), (2, 'two'), (3, 'three');"
  },
  {
    "Query": "SELECT 1 AS column1, 'one' AS column2\nUNION ALL\nSELECT 2, 'two'\nUNION ALL\nSELECT 3, 'three';"
  },
  {
    "Query": "SELECT * FROM (VALUES (1, 'one'), (2, 'two'), (3, 'three')) AS t (num,letter);"
  },
  {
    "Query": "CREATE TABLE test1 (\n    id integer,\n    content varchar\n);"
  },
  {
    "Query": "SELECT content FROM test1 WHERE id = constant;"
  },
  {
    "Query": "CREATE INDEX test1_id_index ON test1 (id);"
  },
  {
    "Query": "CREATE FUNCTION complex_abs_lt(complex, complex) RETURNS bool\n    AS 'filename', 'complex_abs_lt'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE OPERATOR < (\n   leftarg = complex, rightarg = complex, procedure = complex_abs_lt,\n   commutator = > , negator = >= ,\n   restrict = scalarltsel, join = scalarltjoinsel\n);"
  },
  {
    "Query": "CREATE FUNCTION complex_abs_cmp(complex, complex)\n    RETURNS integer\n    AS 'filename'\n    LANGUAGE C IMMUTABLE STRICT;"
  },
  {
    "Query": "CREATE OPERATOR CLASS complex_abs_ops\n    DEFAULT FOR TYPE complex USING btree AS\n        OPERATOR        1       < ,\n        OPERATOR        2       <= ,\n        OPERATOR        3       = ,\n        OPERATOR        4       >= ,\n        OPERATOR        5       > ,\n        FUNCTION        1       complex_abs_cmp(complex, complex);"
  },
  {
    "Query": "CREATE OPERATOR FAMILY integer_ops USING btree;"
  },
  {
    "Query": "CREATE OPERATOR CLASS int8_ops\nDEFAULT FOR TYPE int8 USING btree FAMILY integer_ops AS\n\nOPERATOR 1 < ,\n  OPERATOR 2 <= ,\n  OPERATOR 3 = ,\n  OPERATOR 4 >= ,\n  OPERATOR 5 > ,\n  FUNCTION 1 btint8cmp(int8, int8) ,\n  FUNCTION 2 btint8sortsupport(internal) ,\n  FUNCTION 3 in_range(int8, int8, int8, boolean, boolean) ,\n  FUNCTION 4 btequalimage(oid) ;"
  },
  {
    "Query": "CREATE OPERATOR CLASS int4_ops\nDEFAULT FOR TYPE int4 USING btree FAMILY integer_ops AS\n\nOPERATOR 1 < ,\n  OPERATOR 2 <= ,\n  OPERATOR 3 = ,\n  OPERATOR 4 >= ,\n  OPERATOR 5 > ,\n  FUNCTION 1 btint4cmp(int4, int4) ,\n  FUNCTION 2 btint4sortsupport(internal) ,\n  FUNCTION 3 in_range(int4, int4, int4, boolean, boolean) ,\n  FUNCTION 4 btequalimage(oid) ;"
  },
  {
    "Query": "CREATE OPERATOR CLASS int2_ops\nDEFAULT FOR TYPE int2 USING btree FAMILY integer_ops AS\n\nOPERATOR 1 < ,\n  OPERATOR 2 <= ,\n  OPERATOR 3 = ,\n  OPERATOR 4 >= ,\n  OPERATOR 5 > ,\n  FUNCTION 1 btint2cmp(int2, int2) ,\n  FUNCTION 2 btint2sortsupport(internal) ,\n  FUNCTION 3 in_range(int2, int2, int2, boolean, boolean) ,\n  FUNCTION 4 btequalimage(oid) ;"
  },
  {
    "Query": "ALTER OPERATOR FAMILY integer_ops USING btree ADD\n\nOPERATOR 1 < (int8, int2) ,\n  OPERATOR 2 <= (int8, int2) ,\n  OPERATOR 3 = (int8, int2) ,\n  OPERATOR 4 >= (int8, int2) ,\n  OPERATOR 5 > (int8, int2) ,\n  FUNCTION 1 btint82cmp(int8, int2) ,\n\n\nOPERATOR 1 < (int8, int4) ,\n  OPERATOR 2 <= (int8, int4) ,\n  OPERATOR 3 = (int8, int4) ,\n  OPERATOR 4 >= (int8, int4) ,\n  OPERATOR 5 > (int8, int4) ,\n  FUNCTION 1 btint84cmp(int8, int4) ,\n\n\nOPERATOR 1 < (int4, int2) ,\n  OPERATOR 2 <= (int4, int2) ,\n  OPERATOR 3 = (int4, int2) ,\n  OPERATOR 4 >= (int4, int2) ,\n  OPERATOR 5 > (int4, int2) ,\n  FUNCTION 1 btint42cmp(int4, int2) ,\n\n\nOPERATOR 1 < (int4, int8) ,\n  OPERATOR 2 <= (int4, int8) ,\n  OPERATOR 3 = (int4, int8) ,\n  OPERATOR 4 >= (int4, int8) ,\n  OPERATOR 5 > (int4, int8) ,\n  FUNCTION 1 btint48cmp(int4, int8) ,\n\n\nOPERATOR 1 < (int2, int8) ,\n  OPERATOR 2 <= (int2, int8) ,\n  OPERATOR 3 = (int2, int8) ,\n  OPERATOR 4 >= (int2, int8) ,\n  OPERATOR 5 > (int2, int8) ,\n  FUNCTION 1 btint28cmp(int2, int8) ,\n\n\nOPERATOR 1 < (int2, int4) ,\n  OPERATOR 2 <= (int2, int4) ,\n  OPERATOR 3 = (int2, int4) ,\n  OPERATOR 4 >= (int2, int4) ,\n  OPERATOR 5 > (int2, int4) ,\n  FUNCTION 1 btint24cmp(int2, int4) ,\n\n\nFUNCTION 3 in_range(int4, int4, int8, boolean, boolean) ,\n  FUNCTION 3 in_range(int4, int4, int2, boolean, boolean) ,\n  FUNCTION 3 in_range(int2, int2, int8, boolean, boolean) ,\n  FUNCTION 3 in_range(int2, int2, int4, boolean, boolean) ;"
  },
  {
    "Query": "SELECT * FROM mytable ORDER BY somecol USING ~<~;"
  },
  {
    "Query": "SELECT sum(x) OVER (ORDER BY x RANGE BETWEEN 5 PRECEDING AND 10 FOLLOWING)\n  FROM mytable;"
  },
  {
    "Query": "SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;"
  },
  {
    "Query": "CREATE DATABASE dbname TEMPLATE template0;"
  },
  {
    "Query": "ALTER AGGREGATE myavg(integer) RENAME TO my_average;"
  },
  {
    "Query": "ALTER AGGREGATE myavg(integer) OWNER TO joe;"
  },
  {
    "Query": "ALTER AGGREGATE mypercentile(float8 ORDER BY integer) SET SCHEMA myschema;"
  },
  {
    "Query": "ALTER AGGREGATE mypercentile(float8, integer) SET SCHEMA myschema;"
  },
  {
    "Query": "ALTER PROCEDURE insert_data(integer, integer) RENAME TO insert_record;"
  },
  {
    "Query": "ALTER PROCEDURE insert_data(integer, integer) OWNER TO joe;"
  },
  {
    "Query": "ALTER PROCEDURE insert_data(integer, integer) SET SCHEMA accounting;"
  },
  {
    "Query": "ALTER PROCEDURE insert_data(integer, integer) DEPENDS ON EXTENSION myext;"
  },
  {
    "Query": "ALTER PROCEDURE check_password(text) SET search_path = admin, pg_temp;"
  },
  {
    "Query": "ALTER PROCEDURE check_password(text) RESET search_path;"
  },
  {
    "Query": "SET configuration_parameter TO DEFAULT;"
  },
  {
    "Query": "UPDATE pg_settings SET setting = reset_val WHERE name = 'configuration_parameter';"
  },
  {
    "Query": "DROP POLICY p1 ON my_table;"
  },
  {
    "Query": "DROP TYPE box;"
  },
  {
    "Query": "SELECT '5'::json;"
  },
  {
    "Query": "SELECT '[1, 2, \"foo\", null]'::json;"
  },
  {
    "Query": "SELECT '{\"bar\": \"baz\", \"balance\": 7.77, \"active\": false}'::json;"
  },
  {
    "Query": "SELECT '{\"foo\": [true, \"bar\"], \"tags\": {\"a\": 1, \"b\": null}}'::json;"
  },
  {
    "Query": "SELECT '{\"bar\": \"baz\", \"balance\": 7.77, \"active\":false}'::json;"
  },
  {
    "Query": "SELECT '{\"bar\": \"baz\", \"balance\": 7.77, \"active\":false}'::jsonb"
  },
  {
    "Query": "SELECT '{\"reading\": 1.230e-5}'::json, '{\"reading\": 1.230e-5}'::jsonb;"
  },
  {
    "Query": "SELECT '\"foo\"'::jsonb @> '\"foo\"'::jsonb;"
  },
  {
    "Query": "SELECT '[1, 2, 3]'::jsonb @> '[1, 3]'::jsonb;"
  },
  {
    "Query": "SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;"
  },
  {
    "Query": "SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;"
  },
  {
    "Query": "SELECT '{\"product\": \"PostgreSQL\", \"version\": 9.4, \"jsonb\": true}'::jsonb @> '{\"version\": 9.4}'::jsonb;"
  },
  {
    "Query": "SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb;"
  },
  {
    "Query": "SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;"
  },
  {
    "Query": "SELECT '{\"foo\": {\"bar\": \"baz\"}}'::jsonb @> '{\"bar\": \"baz\"}'::jsonb;"
  },
  {
    "Query": "SELECT '{\"foo\": {\"bar\": \"baz\"}}'::jsonb @> '{\"foo\": {}}'::jsonb;"
  },
  {
    "Query": "SELECT '[\"foo\", \"bar\"]'::jsonb @> '\"bar\"'::jsonb;"
  },
  {
    "Query": "SELECT '\"bar\"'::jsonb @> '[\"bar\"]'::jsonb;"
  },
  {
    "Query": "SELECT '[\"foo\", \"bar\", \"baz\"]'::jsonb ? 'bar';"
  },
  {
    "Query": "SELECT '{\"foo\": \"bar\"}'::jsonb ? 'foo';"
  },
  {
    "Query": "SELECT '{\"foo\": \"bar\"}'::jsonb ? 'bar';"
  },
  {
    "Query": "SELECT '{\"foo\": {\"bar\": \"baz\"}}'::jsonb ? 'bar';"
  },
  {
    "Query": "SELECT '\"foo\"'::jsonb ? 'foo';"
  },
  {
    "Query": "SELECT doc->'site_name' FROM websites\n  WHERE doc @> '{\"tags\":[{\"term\":\"paris\"}, {\"term\":\"food\"}]}';"
  },
  {
    "Query": "SELECT doc->'site_name' FROM websites\n  WHERE doc->'tags' @> '[{\"term\":\"paris\"}, {\"term\":\"food\"}]';"
  },
  {
    "Query": "CREATE INDEX idxgin ON api USING GIN (jdoc);"
  },
  {
    "Query": "CREATE INDEX idxginp ON api USING GIN (jdoc jsonb_path_ops);"
  },
  {
    "Query": "SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @> '{\"company\": \"Magnafone\"}';"
  },
  {
    "Query": "SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc -> 'tags' ? 'qui';"
  },
  {
    "Query": "CREATE INDEX idxgintags ON api USING GIN ((jdoc -> 'tags'));"
  },
  {
    "Query": "SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @> '{\"tags\": [\"qui\"]}';"
  },
  {
    "Query": "SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @? '$.tags[*] ? (@ == \"qui\")';"
  },
  {
    "Query": "SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @@ '$.tags[*] == \"qui\"';"
  },
  {
    "Query": "ROLLBACK PREPARED 'foobar';"
  },
  {
    "Query": "CREATE PROCEDURE transaction_test1()\nLANGUAGE plpythonu\nAS $$\nfor i in range(0, 10):\n    plpy.execute(\"INSERT INTO test1 (a) VALUES (%d)\" % i)\n    if i % 2 == 0:\n        plpy.commit()\n    else:\n        plpy.rollback()\n$$;"
  },
  {
    "Query": "CALL transaction_test1();"
  },
  {
    "Query": "SELECT isbn('978-0-393-04002-9');"
  },
  {
    "Query": "SELECT isbn13('0901690546');"
  },
  {
    "Query": "SELECT issn('1436-4522');"
  },
  {
    "Query": "SELECT upc(ean13('0220356483481'));"
  },
  {
    "Query": "SELECT ean13(upc('220356483481'));"
  },
  {
    "Query": "CREATE TABLE test (id isbn);"
  },
  {
    "Query": "INSERT INTO test VALUES('9780393040029');"
  },
  {
    "Query": "INSERT INTO test VALUES('220500896?');"
  },
  {
    "Query": "INSERT INTO test VALUES('978055215372?');"
  },
  {
    "Query": "SELECT issn('3251231?');"
  },
  {
    "Query": "SELECT ismn('979047213542?');"
  },
  {
    "Query": "SELECT isn_weak(true);"
  },
  {
    "Query": "INSERT INTO test VALUES('978-0-11-000533-4');"
  },
  {
    "Query": "INSERT INTO test VALUES('9780141219307');"
  },
  {
    "Query": "INSERT INTO test VALUES('2-205-00876-X');"
  },
  {
    "Query": "SELECT isn_weak(false);"
  },
  {
    "Query": "SELECT id FROM test WHERE NOT is_valid(id);"
  },
  {
    "Query": "UPDATE test SET id = make_valid(id) WHERE id = '2-205-00876-X!';"
  },
  {
    "Query": "SELECT * FROM test;"
  },
  {
    "Query": "SELECT isbn13(id) FROM test;"
  },
  {
    "Query": "SELECT dblink_send_query('dtest1', 'SELECT * FROM foo WHERE f1 < 3');"
  },
  {
    "Query": "SELECT * FROM name;"
  },
  {
    "Query": "CREATE SEQUENCE serial START 101;"
  },
  {
    "Query": "SELECT nextval('serial');"
  },
  {
    "Query": "SELECT nextval('serial');"
  },
  {
    "Query": "INSERT INTO distributors VALUES (nextval('serial'), 'nothing');"
  },
  {
    "Query": "BEGIN"
  },
  {
    "Query": "COPY distributors FROM 'input_file'"
  },
  {
    "Query": "SELECT setval('serial', max(id)) FROM distributors"
  },
  {
    "Query": "END"
  },
  {
    "Query": "INSERT INTO foo (foo) VALUES (foo);"
  },
  {
    "Query": "INSERT INTO dest (col) SELECT foo + bar FROM src;"
  },
  {
    "Query": "INSERT INTO dest (col) SELECT block.foo + bar FROM src;"
  },
  {
    "Query": "CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n    #variable_conflict use_variable\n    DECLARE\n        curtime timestamp := now();\n    BEGIN\n        UPDATE users SET last_modified = curtime, comment = comment\n          WHERE users.id = id;\n    END;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$\n    <<fn>>\n    DECLARE\n        curtime timestamp := now();\n    BEGIN\n        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment\n          WHERE users.id = stamp_user.id;\n    END;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$\n    BEGIN\n        INSERT INTO logtable VALUES (logtxt, 'now');\n    END;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$\n    DECLARE\n        curtime timestamp;\n    BEGIN\n        curtime := 'now';\n        INSERT INTO logtable VALUES (logtxt, curtime);\n    END;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "PREPARE TRANSACTION 'foobar';"
  },
  {
    "Query": "CREATE TABLE test (a int4);"
  },
  {
    "Query": "CREATE INDEX testidx ON test USING GIN (a);"
  },
  {
    "Query": "SELECT * FROM test WHERE a < 10;"
  },
  {
    "Query": "CREATE FUNCTION execq(text, integer) RETURNS int8\n    AS 'filename'\n    LANGUAGE C STRICT;"
  },
  {
    "Query": "SELECT execq('CREATE TABLE a (x integer)', 0);"
  },
  {
    "Query": "INSERT INTO a VALUES (execq('INSERT INTO a VALUES (0)', 0))"
  },
  {
    "Query": "SELECT execq('INSERT INTO a SELECT x + 2 FROM a', 1)"
  },
  {
    "Query": "SELECT execq('SELECT * FROM a', 10)"
  },
  {
    "Query": "DELETE FROM a"
  },
  {
    "Query": "INSERT INTO a VALUES (execq('SELECT * FROM a', 0) + 1)"
  },
  {
    "Query": "INSERT INTO a SELECT execq('SELECT * FROM a', 0) * x FROM a"
  },
  {
    "Query": "SELECT 'a=>1,a=>2'::hstore;"
  },
  {
    "Query": "CREATE INDEX hidx ON testhstore USING GIST (h);"
  },
  {
    "Query": "CREATE INDEX hidx ON testhstore USING GIN (h);"
  },
  {
    "Query": "CREATE INDEX hidx ON testhstore USING GIST (h gist_hstore_ops(siglen=32));"
  },
  {
    "Query": "CREATE INDEX hidx ON testhstore USING BTREE (h);"
  },
  {
    "Query": "CREATE INDEX hidx ON testhstore USING HASH (h);"
  },
  {
    "Query": "UPDATE tab SET h = h || hstore('c', '3');"
  },
  {
    "Query": "UPDATE tab SET h = delete(h, 'k1');"
  },
  {
    "Query": "CREATE TABLE test (col1 integer, col2 text, col3 text);"
  },
  {
    "Query": "INSERT INTO test VALUES (123, 'foo', 'bar');"
  },
  {
    "Query": "SELECT hstore(t) FROM test AS t;"
  },
  {
    "Query": "CREATE TABLE test (col1 integer, col2 text, col3 text);"
  },
  {
    "Query": "SELECT * FROM populate_record(null::test,\n                              '\"col1\"=>\"456\", \"col2\"=>\"zzz\"');"
  },
  {
    "Query": "CREATE TABLE test (col1 integer, col2 text, col3 text);"
  },
  {
    "Query": "INSERT INTO test VALUES (123, 'foo', 'bar');"
  },
  {
    "Query": "SELECT (r).* FROM (SELECT t #= '\"col3\"=>\"baz\"' AS r FROM test t) s;"
  },
  {
    "Query": "SELECT * FROM each('aaa=>bq, b=>NULL, \"\"=>1');"
  },
  {
    "Query": "SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;"
  },
  {
    "Query": "SELECT key, count(*) FROM\n  (SELECT (each(h)).key FROM testhstore) AS stat\n  GROUP BY key\n  ORDER BY count DESC, key;"
  },
  {
    "Query": "UPDATE tablename SET hstorecol = hstorecol || '';"
  },
  {
    "Query": "ALTER TABLE tablename ALTER hstorecol TYPE hstore USING hstorecol || '';"
  },
  {
    "Query": "CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');"
  },
  {
    "Query": "CREATE PROCEDURE insert_data(a integer, b integer)\nLANGUAGE SQL\nAS $$\nINSERT INTO tbl VALUES (a);\nINSERT INTO tbl VALUES (b);\n$$;"
  },
  {
    "Query": "CALL insert_data(1, 2);"
  },
  {
    "Query": "CREATE FUNCTION transfer_funds() RETURNS void AS $$\ntry:\n    plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n    plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\nexcept plpy.SPIError as e:\n    result = \"error transferring funds: %s\" % e.args\nelse:\n    result = \"funds transferred correctly\"\nplan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\nplpy.execute(plan, [result])\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION transfer_funds2() RETURNS void AS $$\ntry:\n    with plpy.subtransaction():\n        plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n        plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\nexcept plpy.SPIError as e:\n    result = \"error transferring funds: %s\" % e.args\nelse:\n    result = \"funds transferred correctly\"\nplan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\nplpy.execute(plan, [result])\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION transfer_funds_old() RETURNS void AS $$\ntry:\n    subxact = plpy.subtransaction()\n    subxact.enter()\n    try:\n        plpy.execute(\"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\")\n        plpy.execute(\"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\")\n    except:\n        import sys\n        subxact.exit(*sys.exc_info())\n        raise\n    else:\n        subxact.exit(None, None, None)\nexcept plpy.SPIError as e:\n    result = \"error transferring funds: %s\" % e.args\nelse:\n    result = \"funds transferred correctly\"\n\nplan = plpy.prepare(\"INSERT INTO operations (result) VALUES ($1)\", [\"text\"])\nplpy.execute(plan, [result])\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "DROP TEXT SEARCH PARSER my_parser;"
  },
  {
    "Query": "ALTER TRIGGER emp_stamp ON emp RENAME TO emp_track_chgs;"
  },
  {
    "Query": "ALTER TRIGGER emp_stamp ON emp DEPENDS ON EXTENSION emplib;"
  },
  {
    "Query": "INSERT INTO tab (domcol) VALUES ((SELECT domcol FROM tab WHERE false));"
  },
  {
    "Query": "CREATE DOMAIN us_postal_code AS TEXT\nCHECK(\n   VALUE ~ '^\\d{5}$'\nOR VALUE ~ '^\\d{5}-\\d{4}$'\n);"
  },
  {
    "Query": "CREATE TABLE us_snail_addy (\n  address_id SERIAL PRIMARY KEY,\n  street1 TEXT NOT NULL,\n  street2 TEXT,\n  street3 TEXT,\n  city TEXT NOT NULL,\n  postal us_postal_code NOT NULL\n);"
  },
  {
    "Query": "SELECT c FROM test ORDER BY c <-> cube(array[0.5,0.5,0.5]) LIMIT 1;"
  },
  {
    "Query": "SELECT c FROM test ORDER BY c ~> 1 LIMIT 5;"
  },
  {
    "Query": "SELECT c FROM test ORDER BY c ~> 3 DESC LIMIT 5;"
  },
  {
    "Query": "select cube_union('(0,5,2),(2,3,1)', '0');"
  },
  {
    "Query": "select cube_inter('(0,-1),(1,1)', '(-2),(2)');"
  },
  {
    "Query": "select cube_contains('(0,0),(1,1)', '0.5,0.5');"
  },
  {
    "Query": "CLUSTER employees USING employees_ind;"
  },
  {
    "Query": "CLUSTER employees;"
  },
  {
    "Query": "CLUSTER;"
  },
  {
    "Query": "SELECT * FROM mytable WHERE x = $1::bigint;"
  },
  {
    "Query": "SELECT 1 AS FOO, 2 AS \"BAR\";"
  },
  {
    "Query": "DROP SUBSCRIPTION mysub;"
  },
  {
    "Query": "ABORT;"
  },
  {
    "Query": "ALTER FOREIGN TABLE distributors ALTER COLUMN street SET NOT NULL;"
  },
  {
    "Query": "SELECT * FROM pg_create_logical_replication_slot('regression_slot', 'test_decoding');"
  },
  {
    "Query": "SELECT slot_name, plugin, slot_type, database, active, restart_lsn, confirmed_flush_lsn FROM pg_replication_slots"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL)"
  },
  {
    "Query": "CREATE TABLE data(id serial primary key, data text)"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL)"
  },
  {
    "Query": "BEGIN"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_get_changes('regression_slot', NULL, NULL)"
  },
  {
    "Query": "INSERT INTO data(data) VALUES('3')"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL);"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL)"
  },
  {
    "Query": "SELECT * FROM pg_logical_slot_peek_changes('regression_slot', NULL, NULL, 'include-timestamp', 'on')"
  },
  {
    "Query": "SELECT pg_drop_replication_slot('regression_slot')"
  },
  {
    "Query": "SELECT * FROM places ORDER BY location <-> point '(101,456)' LIMIT 10;"
  },
  {
    "Query": "SELECT * INTO films_recent FROM films WHERE date_prod >= '2002-01-01';"
  },
  {
    "Query": "ALTER FOREIGN DATA WRAPPER dbi OPTIONS (ADD foo '1', DROP 'bar');"
  },
  {
    "Query": "ALTER FOREIGN DATA WRAPPER dbi VALIDATOR bob.myvalidator;"
  },
  {
    "Query": "SELECT pg_describe_object(refclassid, refobjid, refobjsubid) AS \"Collation\",\n       pg_describe_object(classid, objid, objsubid) AS \"Object\"\n  FROM pg_depend d JOIN pg_collation c\n       ON refclassid = 'pg_collation'::regclass AND refobjid = c.oid\n  WHERE c.collversion <> pg_collation_actual_version(c.oid)\n  ORDER BY 1, 2;"
  },
  {
    "Query": "ALTER COLLATION \"de_DE\" RENAME TO german;"
  },
  {
    "Query": "ALTER COLLATION \"en_US\" OWNER TO joe;"
  },
  {
    "Query": "SELECT * FROM\nxpath_table('article_id',\n            'article_xml',\n            'articles',\n            '/article/author|/article/pages|/article/title',\n            'date_entered > ''2003-01-01'' ')\nAS t(article_id integer, author text, page_count integer, title text);"
  },
  {
    "Query": "SELECT t.title, p.fullname, p.email\nFROM xpath_table('article_id', 'article_xml', 'articles',\n                 '/article/title|/article/author/@id',\n                 'xpath_string(article_xml,''/article/@date'') > ''2003-03-20'' ')\n       AS t(article_id integer, title text, author_id integer),\n     tblPeopleInfo AS p\nWHERE t.author_id = p.person_id;"
  },
  {
    "Query": "CREATE TABLE test (\n    id int PRIMARY KEY,\n    xml text\n);"
  },
  {
    "Query": "INSERT INTO test VALUES (1, '<doc num=\"C1\">\n<line num=\"L1\"><a>1</a><b>2</b><c>3</c></line>\n<line num=\"L2\"><a>11</a><b>22</b><c>33</c></line>\n</doc>');"
  },
  {
    "Query": "INSERT INTO test VALUES (2, '<doc num=\"C2\">\n<line num=\"L1\"><a>111</a><b>222</b><c>333</c></line>\n<line num=\"L2\"><a>111</a><b>222</b><c>333</c></line>\n</doc>');"
  },
  {
    "Query": "SELECT t.*,i.doc_num FROM\n  xpath_table('id', 'xml', 'test',\n              '/doc/line/@num|/doc/line/a|/doc/line/b|/doc/line/c',\n              'true')\n    AS t(id int, line_num varchar(10), val1 int, val2 int, val3 int),\n  xpath_table('id', 'xml', 'test', '/doc/@num', 'true')\n    AS i(id int, doc_num varchar(10))\nWHERE i.id=t.id AND i.id=1\nORDER BY doc_num, line_num;"
  },
  {
    "Query": "CREATE TABLE shoelace_log (\n    sl_name    text,\nsl_avail   integer,\nlog_who    text,\nlog_when   timestamp\n);"
  },
  {
    "Query": "CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data\n    WHERE NEW.sl_avail <> OLD.sl_avail\n    DO INSERT INTO shoelace_log VALUES (\n                                    NEW.sl_name,\n                                    NEW.sl_avail,\n                                    current_user,\n                                    current_timestamp\n                                );"
  },
  {
    "Query": "UPDATE shoelace_data SET sl_avail = 6 WHERE sl_name = 'sl7';"
  },
  {
    "Query": "SELECT * FROM shoelace_log;"
  },
  {
    "Query": "UPDATE shoelace_data SET sl_avail = 6\n  FROM shoelace_data shoelace_data\n WHERE shoelace_data.sl_name = 'sl7';"
  },
  {
    "Query": "UPDATE shoelace_data SET sl_avail = 6\n WHERE sl_name = 'sl7';"
  },
  {
    "Query": "UPDATE shoelace_data SET sl_color = 'green'\n WHERE sl_name = 'sl7';"
  },
  {
    "Query": "UPDATE shoelace_data SET sl_avail = 0\n WHERE sl_color = 'black';"
  },
  {
    "Query": "INSERT INTO shoelace_log\nSELECT shoelace_data.sl_name, 0,\n       current_user, current_timestamp\n  FROM shoelace_data\n WHERE 0 <> shoelace_data.sl_avail\n   AND shoelace_data.sl_color = 'black';"
  },
  {
    "Query": "CREATE RULE shoe_ins_protect AS ON INSERT TO shoe\n    DO INSTEAD NOTHING;"
  },
  {
    "Query": "CREATE RULE shoe_upd_protect AS ON UPDATE TO shoe\n    DO INSTEAD NOTHING;"
  },
  {
    "Query": "CREATE RULE shoe_del_protect AS ON DELETE TO shoe\n    DO INSTEAD NOTHING;"
  },
  {
    "Query": "CREATE RULE shoelace_ins AS ON INSERT TO shoelace\n    DO INSTEAD\n    INSERT INTO shoelace_data VALUES (\n           NEW.sl_name,\n           NEW.sl_avail,\n           NEW.sl_color,\n           NEW.sl_len,\n           NEW.sl_unit\n    );"
  },
  {
    "Query": "CREATE RULE shoelace_upd AS ON UPDATE TO shoelace\n    DO INSTEAD\n    UPDATE shoelace_data\n       SET sl_name = NEW.sl_name,\n           sl_avail = NEW.sl_avail,\n           sl_color = NEW.sl_color,\n           sl_len = NEW.sl_len,\n           sl_unit = NEW.sl_unit\n     WHERE sl_name = OLD.sl_name;"
  },
  {
    "Query": "CREATE RULE shoelace_del AS ON DELETE TO shoelace\n    DO INSTEAD\n    DELETE FROM shoelace_data\n     WHERE sl_name = OLD.sl_name;"
  },
  {
    "Query": "CREATE RULE shoelace_ins AS ON INSERT TO shoelace\n    DO INSTEAD\n    INSERT INTO shoelace_data VALUES (\n           NEW.sl_name,\n           NEW.sl_avail,\n           NEW.sl_color,\n           NEW.sl_len,\n           NEW.sl_unit\n    )\n    RETURNING\n           shoelace_data.*,\n           (SELECT shoelace_data.sl_len * u.un_fact\n            FROM unit u WHERE shoelace_data.sl_unit = u.un_name);"
  },
  {
    "Query": "CREATE TABLE shoelace_arrive (\n    arr_name    text,\n    arr_quant   integer\n);"
  },
  {
    "Query": "CREATE TABLE shoelace_ok (\n    ok_name     text,\n    ok_quant    integer\n);"
  },
  {
    "Query": "CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok\n    DO INSTEAD\n    UPDATE shoelace\n       SET sl_avail = sl_avail + NEW.ok_quant\n     WHERE sl_name = NEW.ok_name;"
  },
  {
    "Query": "SELECT * FROM shoelace_arrive;"
  },
  {
    "Query": "SELECT * FROM shoelace;"
  },
  {
    "Query": "INSERT INTO shoelace_ok SELECT * FROM shoelace_arrive;"
  },
  {
    "Query": "SELECT * FROM shoelace ORDER BY sl_name;"
  },
  {
    "Query": "SELECT * FROM shoelace_log"
  },
  {
    "Query": "INSERT INTO shoelace_ok\nSELECT shoelace_arrive.arr_name, shoelace_arrive.arr_quant\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok;"
  },
  {
    "Query": "UPDATE shoelace\n   SET sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace\n WHERE shoelace.sl_name = shoelace_arrive.arr_name;"
  },
  {
    "Query": "UPDATE shoelace_data\n   SET sl_name = shoelace.sl_name,\n       sl_avail = shoelace.sl_avail + shoelace_arrive.arr_quant,\n       sl_color = shoelace.sl_color,\n       sl_len = shoelace.sl_len,\n       sl_unit = shoelace.sl_unit\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace, shoelace old,\n       shoelace new, shoelace_data shoelace_data\n WHERE shoelace.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = shoelace.sl_name;"
  },
  {
    "Query": "UPDATE shoelace_data\n   SET sl_name = s.sl_name,\n       sl_avail = s.sl_avail + shoelace_arrive.arr_quant,\n       sl_color = s.sl_color,\n       sl_len = s.sl_len,\n       sl_unit = s.sl_unit\n  FROM shoelace_arrive shoelace_arrive, shoelace_ok shoelace_ok,\n       shoelace_ok old, shoelace_ok new,\n       shoelace shoelace, shoelace old,\n       shoelace new, shoelace_data shoelace_data,\n       shoelace old, shoelace new,\n       shoelace_data s, unit u\n WHERE s.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = s.sl_name;"
  },
  {
    "Query": "INSERT INTO shoelace_log\nSELECT s.sl_name,\n       s.sl_avail + shoelace_arrive.arr_quant,\n       current_user,\n       current_timestamp\n  FROM shoelace_arrive shoelace_arrive, shoelace_data shoelace_data,\n       shoelace_data s\n WHERE s.sl_name = shoelace_arrive.arr_name\n   AND shoelace_data.sl_name = s.sl_name\n   AND s.sl_avail + shoelace_arrive.arr_quant <> s.sl_avail;"
  },
  {
    "Query": "UPDATE shoelace_data\n   SET sl_avail = shoelace_data.sl_avail + shoelace_arrive.arr_quant\n  FROM shoelace_arrive shoelace_arrive,\n       shoelace_data shoelace_data,\n       shoelace_data s\n WHERE s.sl_name = shoelace_arrive.sl_name\n   AND shoelace_data.sl_name = s.sl_name;"
  },
  {
    "Query": "INSERT INTO shoelace VALUES ('sl9', 0, 'pink', 35.0, 'inch', 0.0);"
  },
  {
    "Query": "INSERT INTO shoelace VALUES ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);"
  },
  {
    "Query": "CREATE VIEW shoelace_mismatch AS\n    SELECT * FROM shoelace WHERE NOT EXISTS\n        (SELECT shoename FROM shoe WHERE slcolor = sl_color);"
  },
  {
    "Query": "SELECT * FROM shoelace_mismatch;"
  },
  {
    "Query": "CREATE VIEW shoelace_can_delete AS\n    SELECT * FROM shoelace_mismatch WHERE sl_avail = 0;"
  },
  {
    "Query": "DELETE FROM shoelace WHERE EXISTS\n    (SELECT * FROM shoelace_can_delete\n             WHERE sl_name = shoelace.sl_name);"
  },
  {
    "Query": "SELECT * FROM shoelace;"
  },
  {
    "Query": "SELECT c.column_name, c.data_type, e.data_type AS element_type\nFROM information_schema.columns c LEFT JOIN information_schema.element_types e\n     ON ((c.table_catalog, c.table_schema, c.table_name, 'TABLE', c.dtd_identifier)\n       = (e.object_catalog, e.object_schema, e.object_name, e.object_type, e.collection_type_identifier))\nWHERE c.table_schema = '...' AND c.table_name = '...'\nORDER BY c.ordinal_position;"
  },
  {
    "Query": "CREATE TABLE cities (\n    name            text,\n    population      float,\n    elevation       int\n);"
  },
  {
    "Query": "CREATE TABLE capitals (\n    state           char(2)\n) INHERITS (cities);"
  },
  {
    "Query": "SELECT name, elevation\n    FROM cities\n    WHERE elevation > 500;"
  },
  {
    "Query": "SELECT name, elevation\n    FROM ONLY cities\n    WHERE elevation > 500;"
  },
  {
    "Query": "SELECT name, elevation\n    FROM cities*\n    WHERE elevation > 500;"
  },
  {
    "Query": "SELECT c.tableoid, c.name, c.elevation\nFROM cities c\nWHERE c.elevation > 500;"
  },
  {
    "Query": "SELECT p.relname, c.name, c.elevation\nFROM cities c, pg_class p\nWHERE c.elevation > 500 AND c.tableoid = p.oid;"
  },
  {
    "Query": "SELECT c.tableoid::regclass, c.name, c.elevation\nFROM cities c\nWHERE c.elevation > 500;"
  },
  {
    "Query": "INSERT INTO cities (name, population, elevation, state)\nVALUES ('Albany', NULL, NULL, 'NY');"
  },
  {
    "Query": "ALTER TABLE distributors ADD COLUMN address varchar(30);"
  },
  {
    "Query": "ALTER TABLE measurements\n  ADD COLUMN mtime timestamp with time zone DEFAULT now();"
  },
  {
    "Query": "ALTER TABLE transactions\n  ADD COLUMN status varchar(30) DEFAULT 'old',\n  ALTER COLUMN status SET default 'current';"
  },
  {
    "Query": "ALTER TABLE distributors DROP COLUMN address RESTRICT;"
  },
  {
    "Query": "ALTER TABLE distributors\n    ALTER COLUMN address TYPE varchar(80),\n    ALTER COLUMN name TYPE varchar(100);"
  },
  {
    "Query": "ALTER TABLE foo\n    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';"
  },
  {
    "Query": "ALTER TABLE foo\n    ALTER COLUMN foo_timestamp DROP DEFAULT,\n    ALTER COLUMN foo_timestamp TYPE timestamp with time zone\n    USING\n        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',\n    ALTER COLUMN foo_timestamp SET DEFAULT now();"
  },
  {
    "Query": "ALTER TABLE distributors RENAME COLUMN address TO city;"
  },
  {
    "Query": "ALTER TABLE distributors RENAME TO suppliers;"
  },
  {
    "Query": "ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;"
  },
  {
    "Query": "ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;"
  },
  {
    "Query": "ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;"
  },
  {
    "Query": "ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);"
  },
  {
    "Query": "ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;"
  },
  {
    "Query": "ALTER TABLE distributors DROP CONSTRAINT zipchk;"
  },
  {
    "Query": "ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;"
  },
  {
    "Query": "ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);"
  },
  {
    "Query": "ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;"
  },
  {
    "Query": "ALTER TABLE distributors VALIDATE CONSTRAINT distfk;"
  },
  {
    "Query": "ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);"
  },
  {
    "Query": "ALTER TABLE distributors ADD PRIMARY KEY (dist_id);"
  },
  {
    "Query": "ALTER TABLE distributors SET TABLESPACE fasttablespace;"
  },
  {
    "Query": "ALTER TABLE myschema.distributors SET SCHEMA yourschema;"
  },
  {
    "Query": "CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);"
  },
  {
    "Query": "ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,\n    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;"
  },
  {
    "Query": "ALTER TABLE measurement\n    ATTACH PARTITION measurement_y2016m07 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01');"
  },
  {
    "Query": "ALTER TABLE cities\n    ATTACH PARTITION cities_ab FOR VALUES IN ('a', 'b');"
  },
  {
    "Query": "ALTER TABLE orders\n    ATTACH PARTITION orders_p4 FOR VALUES WITH (MODULUS 4, REMAINDER 3);"
  },
  {
    "Query": "ALTER TABLE cities\n    ATTACH PARTITION cities_partdef DEFAULT;"
  },
  {
    "Query": "ALTER TABLE measurement\n    DETACH PARTITION measurement_y2015m12;"
  },
  {
    "Query": "CREATE INDEX access_log_client_ip_ix ON access_log (client_ip)\nWHERE NOT (client_ip > inet '192.168.100.0' AND\n           client_ip < inet '192.168.100.255');"
  },
  {
    "Query": "SELECT *\nFROM access_log\nWHERE url = '/index.html' AND client_ip = inet '212.78.10.32';"
  },
  {
    "Query": "SELECT *\nFROM access_log\nWHERE url = '/index.html' AND client_ip = inet '192.168.100.23';"
  },
  {
    "Query": "CREATE INDEX orders_unbilled_index ON orders (order_nr)\n    WHERE billed is not true;"
  },
  {
    "Query": "SELECT * FROM orders WHERE billed is not true AND order_nr < 10000;"
  },
  {
    "Query": "SELECT * FROM orders WHERE billed is not true AND amount > 5000.00;"
  },
  {
    "Query": "SELECT * FROM orders WHERE order_nr = 3501;"
  },
  {
    "Query": "CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)\n    WHERE success;"
  },
  {
    "Query": "CREATE INDEX mytable_cat_1 ON mytable (data) WHERE category = 1;"
  },
  {
    "Query": "CREATE INDEX mytable_cat_2 ON mytable (data) WHERE category = 2;"
  },
  {
    "Query": "CREATE INDEX mytable_cat_3 ON mytable (data) WHERE category = 3;"
  },
  {
    "Query": "CREATE INDEX mytable_cat_N ON mytable (data) WHERE category = N"
  },
  {
    "Query": "CREATE INDEX mytable_cat_data ON mytable (category, data);"
  },
  {
    "Query": "CREATE INDEX ON my_table USING GIST (my_inet_column inet_ops);"
  },
  {
    "Query": "CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');"
  },
  {
    "Query": "CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');"
  },
  {
    "Query": "CREATE TABLE person (\n    name text,\n    current_mood mood\n);"
  },
  {
    "Query": "INSERT INTO person VALUES ('Moe', 'happy');"
  },
  {
    "Query": "SELECT * FROM person WHERE current_mood = 'happy';"
  },
  {
    "Query": "INSERT INTO person VALUES ('Larry', 'sad');"
  },
  {
    "Query": "INSERT INTO person VALUES ('Curly', 'ok');"
  },
  {
    "Query": "SELECT * FROM person WHERE current_mood > 'sad';"
  },
  {
    "Query": "SELECT * FROM person WHERE current_mood > 'sad' ORDER BY current_mood"
  },
  {
    "Query": "SELECT name\nFROM person\nWHERE current_mood = (SELECT MIN(current_mood) FROM person)"
  },
  {
    "Query": "CREATE TYPE happiness AS ENUM ('happy', 'very happy', 'ecstatic');"
  },
  {
    "Query": "CREATE TABLE holidays (\n    num_weeks integer,\n    happiness happiness\n);"
  },
  {
    "Query": "INSERT INTO holidays(num_weeks,happiness) VALUES (4, 'happy');"
  },
  {
    "Query": "INSERT INTO holidays(num_weeks,happiness) VALUES (6, 'very happy');"
  },
  {
    "Query": "INSERT INTO holidays(num_weeks,happiness) VALUES (8, 'ecstatic');"
  },
  {
    "Query": "INSERT INTO holidays(num_weeks,happiness) VALUES (2, 'sad');"
  },
  {
    "Query": "SELECT person.name, holidays.num_weeks FROM person, holidays\n  WHERE person.current_mood = holidays.happiness"
  },
  {
    "Query": "SELECT person.name, holidays.num_weeks FROM person, holidays\n  WHERE person.current_mood::text = holidays.happiness::text;"
  },
  {
    "Query": "CREATE DATABASE dbname OWNER rolename;"
  },
  {
    "Query": "SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;"
  },
  {
    "Query": "SELECT pg_stat_get_backend_pid(s.backendid) AS pid,\n       pg_stat_get_backend_activity(s.backendid) AS query\n    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;"
  },
  {
    "Query": "DROP OPERATOR ^ (integer, integer);"
  },
  {
    "Query": "DROP OPERATOR ~ (none, bit);"
  },
  {
    "Query": "DROP OPERATOR ! (bigint, none);"
  },
  {
    "Query": "DROP OPERATOR ~ (none, bit), ! (bigint, none);"
  },
  {
    "Query": "SELECT depname, empno, salary, avg(salary) OVER (PARTITION BY depname) FROM empsalary;"
  },
  {
    "Query": "SELECT depname, empno, salary,\n       rank() OVER (PARTITION BY depname ORDER BY salary DESC)\nFROM empsalary;"
  },
  {
    "Query": "SELECT salary, sum(salary) OVER () FROM empsalary;"
  },
  {
    "Query": "SELECT salary, sum(salary) OVER (ORDER BY salary) FROM empsalary;"
  },
  {
    "Query": "SELECT depname, empno, salary, enroll_date\nFROM\n  (SELECT depname, empno, salary, enroll_date,\n          rank() OVER (PARTITION BY depname ORDER BY salary DESC, empno) AS pos\n     FROM empsalary\n  ) AS ss\nWHERE pos < 3;"
  },
  {
    "Query": "SELECT sum(salary) OVER w, avg(salary) OVER w\n  FROM empsalary\n  WINDOW w AS (PARTITION BY depname ORDER BY salary DESC);"
  },
  {
    "Query": "CREATE INDEX bloomidx ON tbloom USING bloom (i1,i2,i3)\n       WITH (length=80, col1=2, col2=2, col3=4);"
  },
  {
    "Query": "CREATE TABLE tbloom AS\n   SELECT\n     (random() * 1000000)::int as i1,\n     (random() * 1000000)::int as i2,\n     (random() * 1000000)::int as i3,\n     (random() * 1000000)::int as i4,\n     (random() * 1000000)::int as i5,\n     (random() * 1000000)::int as i6\n   FROM\n  generate_series(1,10000000);"
  },
  {
    "Query": "SELECT 10000000"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451;"
  },
  {
    "Query": "CREATE INDEX btreeidx ON tbloom (i1, i2, i3, i4, i5, i6);"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451"
  },
  {
    "Query": "CREATE INDEX bloomidx ON tbloom USING bloom (i1, i2, i3, i4, i5, i6);"
  },
  {
    "Query": "EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 898732 AND i5 = 123451"
  },
  {
    "Query": "CREATE INDEX btreeidx1 ON tbloom (i1);"
  },
  {
    "Query": "CREATE OPERATOR CLASS text_ops\nDEFAULT FOR TYPE text USING bloom AS\n    OPERATOR    1   =(text, text),\n    FUNCTION    1   hashtext(text);"
  },
  {
    "Query": "CREATE TYPE complex AS (\n    r       double precision,\n    i       double precision\n);"
  },
  {
    "Query": "CREATE TYPE inventory_item AS (\n    name            text,\n    supplier_id     integer,\n    price           numeric\n);"
  },
  {
    "Query": "CREATE TABLE on_hand (\n    item      inventory_item,\n    count     integer\n);"
  },
  {
    "Query": "INSERT INTO on_hand VALUES (ROW('fuzzy dice', 42, 1.99), 1000);"
  },
  {
    "Query": "CREATE FUNCTION price_extension(inventory_item, integer) RETURNS numeric\nAS 'SELECT $1.price * $2' LANGUAGE SQL;"
  },
  {
    "Query": "SELECT price_extension(item, 10) FROM on_hand;"
  },
  {
    "Query": "CREATE TABLE inventory_item (\n    name            text,\n    supplier_id     integer REFERENCES suppliers,\n    price           numeric CHECK (price > 0)\n);"
  },
  {
    "Query": "SELECT item.name FROM on_hand WHERE item.price > 9.99;"
  },
  {
    "Query": "SELECT (item).name FROM on_hand WHERE (item).price > 9.99;"
  },
  {
    "Query": "SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price > 9.99;"
  },
  {
    "Query": "INSERT INTO mytab (complex_col) VALUES((1.1,2.2));"
  },
  {
    "Query": "INSERT INTO mytab (complex_col.r, complex_col.i) VALUES(1.1, 2.2);"
  },
  {
    "Query": "SELECT c FROM inventory_item c;"
  },
  {
    "Query": "SELECT c.* FROM inventory_item c;"
  },
  {
    "Query": "SELECT c.name, c.supplier_id, c.price FROM inventory_item c;"
  },
  {
    "Query": "SELECT (myfunc(x)).* FROM some_table;"
  },
  {
    "Query": "SELECT (myfunc(x)).a, (myfunc(x)).b, (myfunc(x)).c FROM some_table;"
  },
  {
    "Query": "SELECT m.* FROM some_table, LATERAL myfunc(x) AS m;"
  },
  {
    "Query": "SELECT somefunc(c.*) FROM inventory_item c;"
  },
  {
    "Query": "SELECT somefunc(c) FROM inventory_item c;"
  },
  {
    "Query": "SELECT * FROM inventory_item c ORDER BY c;"
  },
  {
    "Query": "SELECT * FROM inventory_item c ORDER BY c.*;"
  },
  {
    "Query": "SELECT * FROM inventory_item c ORDER BY ROW(c.*);"
  },
  {
    "Query": "SELECT * FROM inventory_item c ORDER BY ROW(c.name, c.supplier_id, c.price);"
  },
  {
    "Query": "SELECT * FROM inventory_item c ORDER BY (c.name, c.supplier_id, c.price);"
  },
  {
    "Query": "SELECT c.name FROM inventory_item c WHERE c.price > 1000;"
  },
  {
    "Query": "SELECT name(c) FROM inventory_item c WHERE price(c) > 1000;"
  },
  {
    "Query": "SELECT somefunc(c) FROM inventory_item c;"
  },
  {
    "Query": "SELECT somefunc(c.*) FROM inventory_item c;"
  },
  {
    "Query": "SELECT c.somefunc FROM inventory_item c;"
  },
  {
    "Query": "DROP LANGUAGE plsample;"
  },
  {
    "Query": "CREATE TABLE test (\n    i int,\n    v varchar\n);"
  },
  {
    "Query": "INSERT INTO test (i, v) VALUES (1, 'first line');"
  },
  {
    "Query": "INSERT INTO test (i, v) VALUES (2, 'second line');"
  },
  {
    "Query": "INSERT INTO test (i, v) VALUES (3, 'third line');"
  },
  {
    "Query": "INSERT INTO test (i, v) VALUES (4, 'immortal');"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION test_munge() RETURNS SETOF test AS $$\n    my $rv = spi_exec_query('select i, v from test;');\n    my $status = $rv->{status};\n    my $nrows = $rv->{processed};\n    foreach my $rn (0 .. $nrows - 1) {\n        my $row = $rv->{rows}[$rn];\n        $row->{i} += 200 if defined($row->{i});\n        $row->{v} =~ tr/A-Za-z/a-zA-Z/ if (defined($row->{v}));\n        return_next($row);\n    }\n    return undef;\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT * FROM test_munge();"
  },
  {
    "Query": "CREATE TYPE foo_type AS (the_num INTEGER, the_text TEXT);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION lotsa_md5 (INTEGER) RETURNS SETOF foo_type AS $$\n    use Digest::MD5 qw(md5_hex);\n    my $file = '/usr/share/dict/words';\n    my $t = localtime;\n    elog(NOTICE, \"opening file $file at $t\" );\n    open my $fh, '<', $file # ooh, it's a file access!\n        or elog(ERROR, \"cannot open $file for reading: $!\");\n    my @words = <$fh>;\n    close $fh;\n    $t = localtime;\n    elog(NOTICE, \"closed file $file at $t\");\n    chomp(@words);\n    my $row;\n    my $sth = spi_query(\"SELECT * FROM generate_series(1,$_[0]) AS b(a)\");\n    while (defined ($row = spi_fetchrow($sth))) {\n        return_next({\n            the_num => $row->{a},\n            the_text => md5_hex($words[rand @words])\n        });\n    }\n    return;\n$$ LANGUAGE plperlu;"
  },
  {
    "Query": "SELECT * from lotsa_md5(500);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION init() RETURNS VOID AS $$\n        $_SHARED{my_plan} = spi_prepare('SELECT (now() + $1)::date AS now',\n                                        'INTERVAL');\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION add_time( INTERVAL ) RETURNS TEXT AS $$\n        return spi_exec_prepared(\n                $_SHARED{my_plan},\n                $_[0]\n        )->{rows}->[0]->{now};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION done() RETURNS VOID AS $$\n        spi_freeplan( $_SHARED{my_plan});\n        undef $_SHARED{my_plan};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT init();"
  },
  {
    "Query": "SELECT add_time('1 day'), add_time('2 days'), add_time('3 days');"
  },
  {
    "Query": "SELECT done();"
  },
  {
    "Query": "CREATE TABLE hosts AS SELECT id, ('192.168.1.'||id)::inet AS address\n                      FROM generate_series(1,3) AS id;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION init_hosts_query() RETURNS VOID AS $$\n        $_SHARED{plan} = spi_prepare('SELECT * FROM hosts\n                                      WHERE address << $1', 'inet');\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION query_hosts(inet) RETURNS SETOF hosts AS $$\n        return spi_exec_prepared(\n                $_SHARED{plan},\n                {limit => 2},\n                $_[0]\n        )->{rows};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION release_hosts_query() RETURNS VOID AS $$\n        spi_freeplan($_SHARED{plan});\n        undef $_SHARED{plan};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT init_hosts_query();"
  },
  {
    "Query": "SELECT query_hosts('192.168.1.0/30');"
  },
  {
    "Query": "SELECT release_hosts_query();"
  },
  {
    "Query": "CREATE PROCEDURE transaction_test1()\nLANGUAGE plperl\nAS $$\nforeach my $i (0..9) {\n    spi_exec_query(\"INSERT INTO test1 (a) VALUES ($i)\");\n    if ($i % 2 == 0) {\n        spi_commit();\n    } else {\n        spi_rollback();\n    }\n}\n$$;"
  },
  {
    "Query": "CALL transaction_test1();"
  },
  {
    "Query": "DO 'elog(WARNING, join \", \", sort keys %INC)' LANGUAGE plperl"
  },
  {
    "Query": "CREATE TABLE child1000(check (key between 1000 and 1999)) INHERITS(parent);"
  },
  {
    "Query": "CREATE TABLE child2000(check (key between 2000 and 2999)) INHERITS(parent);"
  },
  {
    "Query": "SELECT * FROM parent WHERE key = 2400"
  },
  {
    "Query": "CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);"
  },
  {
    "Query": "INSERT INTO foo VALUES (1, 2, 'three');"
  },
  {
    "Query": "INSERT INTO foo VALUES (4, 5, 'six');"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS\n$BODY$\nDECLARE\n    r foo%rowtype;\nBEGIN\n    FOR r IN\n        SELECT * FROM foo WHERE fooid > 0\n    LOOP\n        -- can do some processing here\n        RETURN NEXT r; -- return current row of SELECT\n    END LOOP;\n    RETURN;\nEND;\n$BODY$\nLANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT * FROM get_all_foo();"
  },
  {
    "Query": "CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS\n$BODY$\nBEGIN\n    RETURN QUERY SELECT flightid\n                   FROM flight\n                  WHERE flightdate >= $1\n                    AND flightdate < ($1 + 1);\n\n    -- Since execution is not finished, we can check whether rows were returned\n    -- and raise exception if not.\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'No flight at %.', $1;\n    END IF;\n\n    RETURN;\n END;\n$BODY$\nLANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT * FROM get_available_flightid(CURRENT_DATE);"
  },
  {
    "Query": "CREATE PROCEDURE triple(INOUT x int)\nLANGUAGE plpgsql\nAS $$\nBEGIN\n    x := x * 3;\nEND;\n$$;"
  },
  {
    "Query": "DO $$\nDECLARE myvar int := 5"
  },
  {
    "Query": "END"
  },
  {
    "Query": "BEGIN"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE FUNCTION refresh_mviews() RETURNS integer AS $$\nDECLARE\n    mviews RECORD;\nBEGIN\n    RAISE NOTICE 'Refreshing all materialized views...';\n\n    FOR mviews IN\n       SELECT n.nspname AS mv_schema,\n              c.relname AS mv_name,\n              pg_catalog.pg_get_userbyid(c.relowner) AS owner\n         FROM pg_catalog.pg_class c\n    LEFT JOIN pg_catalog.pg_namespace n ON (n.oid = c.relnamespace)\n        WHERE c.relkind = 'm'\n     ORDER BY 1\n    LOOP\n\n        -- Now \"mviews\" has one record with information about the materialized view\n\n        RAISE NOTICE 'Refreshing materialized view %.% (owner: %)...',\n                     quote_ident(mviews.mv_schema),\n                     quote_ident(mviews.mv_name),\n                     quote_ident(mviews.owner);\n        EXECUTE format('REFRESH MATERIALIZED VIEW %I.%I', mviews.mv_schema, mviews.mv_name);\n    END LOOP;\n\n    RAISE NOTICE 'Done refreshing materialized views.';\n    RETURN 1;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION sum(int[]) RETURNS int8 AS $$\nDECLARE\n  s int8 := 0;\n  x int;\nBEGIN\n  FOREACH x IN ARRAY $1\n  LOOP\n    s := s + x;\n  END LOOP;\n  RETURN s;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$\nDECLARE\n  x int[];\nBEGIN\n  FOREACH x SLICE 1 IN ARRAY $1\n  LOOP\n    RAISE NOTICE 'row = %', x;\n  END LOOP;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);"
  },
  {
    "Query": "INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE TABLE db (a INT PRIMARY KEY, b TEXT);"
  },
  {
    "Query": "CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS\n$$\nBEGIN\n    LOOP\n        -- first try to update the key\n        UPDATE db SET b = data WHERE a = key;\n        IF found THEN\n            RETURN;\n        END IF;\n        -- not there, so try to insert the key\n        -- if someone else inserts the same key concurrently,\n        -- we could get a unique-key failure\n        BEGIN\n            INSERT INTO db(a,b) VALUES (key, data);\n            RETURN;\n        EXCEPTION WHEN unique_violation THEN\n            -- Do nothing, and loop to try the UPDATE again.\n        END;\n    END LOOP;\nEND;\n$$\nLANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT merge_db(1, 'david');"
  },
  {
    "Query": "SELECT merge_db(1, 'dennis');"
  },
  {
    "Query": "BEGIN"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$\nBEGIN\n  RETURN inner_func();\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$\nDECLARE\n  stack text;\nBEGIN\n  GET DIAGNOSTICS stack = PG_CONTEXT;\n  RAISE NOTICE E'--- Call Stack ---\\n%', stack;\n  RETURN 1;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "SELECT outer_func();"
  },
  {
    "Query": "SELECT c.oid::regclass as table_name,\n       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age\nFROM pg_class c\nLEFT JOIN pg_class t ON c.reltoastrelid = t.oid\nWHERE c.relkind IN ('r', 'm');"
  },
  {
    "Query": "SELECT datname, age(datfrozenxid) FROM pg_database;"
  },
  {
    "Query": "CREATE TABLE my_first_table (\n    first_column text,\n    second_column integer\n);"
  },
  {
    "Query": "CREATE TABLE products (\n    product_no integer,\n    name text,\n    price numeric\n);"
  },
  {
    "Query": "DROP TABLE my_first_table;"
  },
  {
    "Query": "DROP TABLE products;"
  },
  {
    "Query": "SELECT SESSION_USER, CURRENT_USER;"
  },
  {
    "Query": "SET SESSION AUTHORIZATION 'paul'"
  },
  {
    "Query": "SELECT SESSION_USER, CURRENT_USER;"
  },
  {
    "Query": "SHOW DateStyle;"
  },
  {
    "Query": "SHOW geqo;"
  },
  {
    "Query": "SHOW ALL;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION set_var(name text, val text) RETURNS text AS $$\n    if ($_SHARED{$_[0]} = $_[1]) {\n        return 'ok';\n    } else {\n        return \"cannot set shared variable $_[0] to $_[1]\";\n    }\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION get_var(name text) RETURNS text AS $$\n    return $_SHARED{$_[0]};\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT set_var('sample', 'Hello, PL/Perl!  How''s tricks?');"
  },
  {
    "Query": "SELECT get_var('sample');"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION myfuncs() RETURNS void AS $$\n    $_SHARED{myquote} = sub {\n        my $arg = shift;\n        $arg =~ s/(['\\\\])/\\\\$1/g;\n        return \"'$arg'\";\n    };\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "SELECT myfuncs();"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION use_quote(TEXT) RETURNS text AS $$\n    my $text_to_quote = shift;\n    my $qfunc = $_SHARED{myquote};\n    return &$qfunc($text_to_quote);\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "DROP RULE newrule ON mytable;"
  },
  {
    "Query": "ALTER USER MAPPING FOR bob SERVER foo OPTIONS (SET password 'public');"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (1);"
  },
  {
    "Query": "SAVEPOINT my_savepoint;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (2);"
  },
  {
    "Query": "ROLLBACK TO SAVEPOINT my_savepoint;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (3);"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (3);"
  },
  {
    "Query": "SAVEPOINT my_savepoint;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (4);"
  },
  {
    "Query": "RELEASE SAVEPOINT my_savepoint;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "BEGIN;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (1);"
  },
  {
    "Query": "SAVEPOINT my_savepoint;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (2);"
  },
  {
    "Query": "SAVEPOINT my_savepoint;"
  },
  {
    "Query": "INSERT INTO table1 VALUES (3);"
  },
  {
    "Query": "ROLLBACK TO SAVEPOINT my_savepoint;"
  },
  {
    "Query": "SELECT * FROM table1;"
  },
  {
    "Query": "RELEASE SAVEPOINT my_savepoint;"
  },
  {
    "Query": "ROLLBACK TO SAVEPOINT my_savepoint;"
  },
  {
    "Query": "SELECT * FROM table1;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "CREATE TABLE emp (\n    empname text,\n    salary integer,\n    last_date timestamp,\n    last_user text\n);"
  },
  {
    "Query": "CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$\n    BEGIN\n        -- Check that empname and salary are given\n        IF NEW.empname IS NULL THEN\n            RAISE EXCEPTION 'empname cannot be null';\n        END IF;\n        IF NEW.salary IS NULL THEN\n            RAISE EXCEPTION '% cannot have null salary', NEW.empname;\n        END IF;\n\n        -- Who works for us when they must pay for it?\n        IF NEW.salary < 0 THEN\n            RAISE EXCEPTION '% cannot have a negative salary', NEW.empname;\n        END IF;\n\n        -- Remember who changed the payroll when\n        NEW.last_date := current_timestamp;\n        NEW.last_user := current_user;\n        RETURN NEW;\n    END;\n$emp_stamp$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp\n    FOR EACH ROW EXECUTE FUNCTION emp_stamp();"
  },
  {
    "Query": "CREATE TABLE emp (\n    empname           text NOT NULL,\n    salary            integer\n);"
  },
  {
    "Query": "CREATE TABLE emp_audit(\n    operation         char(1)   NOT NULL,\n    stamp             timestamp NOT NULL,\n    userid            text      NOT NULL,\n    empname           text      NOT NULL,\n    salary integer\n);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n    BEGIN\n        --\n        -- Create a row in emp_audit to reflect the operation performed on emp,\n        -- making use of the special variable TG_OP to work out the operation.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;\n        END IF;\n        RETURN NULL; -- result is ignored since this is an AFTER trigger\n    END;\n$emp_audit$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER emp_audit\nAFTER INSERT OR UPDATE OR DELETE ON emp\n    FOR EACH ROW EXECUTE FUNCTION process_emp_audit();"
  },
  {
    "Query": "CREATE TABLE emp (\n    empname           text PRIMARY KEY,\n    salary            integer\n);"
  },
  {
    "Query": "CREATE TABLE emp_audit(\n    operation         char(1)   NOT NULL,\n    userid            text      NOT NULL,\n    empname           text      NOT NULL,\n    salary            integer,\n    stamp             timestamp NOT NULL\n);"
  },
  {
    "Query": "CREATE VIEW emp_view AS\n    SELECT e.empname,\n           e.salary,\n           max(ea.stamp) AS last_updated\n      FROM emp e\n      LEFT JOIN emp_audit ea ON ea.empname = e.empname\n     GROUP BY 1, 2;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$\n    BEGIN\n        --\n        -- Perform the required operation on emp, and create a row in emp_audit\n        -- to reflect the change made to emp.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            DELETE FROM emp WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            OLD.last_updated = now();\n            INSERT INTO emp_audit VALUES('D', user, OLD.*);\n            RETURN OLD;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;\n            IF NOT FOUND THEN RETURN NULL; END IF;\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('U', user, NEW.*);\n            RETURN NEW;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp VALUES(NEW.empname, NEW.salary);\n\n            NEW.last_updated = now();\n            INSERT INTO emp_audit VALUES('I', user, NEW.*);\n            RETURN NEW;\n        END IF;\n    END;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER emp_audit\nINSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view\n    FOR EACH ROW EXECUTE FUNCTION update_emp_view();"
  },
  {
    "Query": "CREATE TABLE time_dimension (\n    time_key                    integer NOT NULL,\n    day_of_week                 integer NOT NULL,\n    day_of_month                integer NOT NULL,\n    month                       integer NOT NULL,\n    quarter                     integer NOT NULL,\n    year                        integer NOT NULL\n);"
  },
  {
    "Query": "CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);"
  },
  {
    "Query": "CREATE TABLE sales_fact (\n    time_key                    integer NOT NULL,\n    product_key                 integer NOT NULL,\n    store_key                   integer NOT NULL,\n    amount_sold                 numeric(12,2) NOT NULL,\n    units_sold                  integer NOT NULL,\n    amount_cost                 numeric(12,2) NOT NULL\n);"
  },
  {
    "Query": "CREATE INDEX sales_fact_time ON sales_fact(time_key);"
  },
  {
    "Query": "CREATE TABLE sales_summary_bytime (\n    time_key                    integer NOT NULL,\n    amount_sold                 numeric(15,2) NOT NULL,\n    units_sold                  numeric(12) NOT NULL,\n    amount_cost                 numeric(15,2) NOT NULL\n);"
  },
  {
    "Query": "CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER\nAS $maint_sales_summary_bytime$\n    DECLARE\n        delta_time_key          integer;\n        delta_amount_sold       numeric(15,2);\n        delta_units_sold        numeric(12);\n        delta_amount_cost       numeric(15,2);\n    BEGIN\n\n        -- Work out the increment/decrement amount(s).\n        IF (TG_OP = 'DELETE') THEN\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = -1 * OLD.amount_sold;\n            delta_units_sold = -1 * OLD.units_sold;\n            delta_amount_cost = -1 * OLD.amount_cost;\n\n        ELSIF (TG_OP = 'UPDATE') THEN\n\n            -- forbid updates that change the time_key -\n            -- (probably not too onerous, as DELETE + INSERT is how most\n            -- changes will be made).\n            IF ( OLD.time_key != NEW.time_key) THEN\n                RAISE EXCEPTION 'Update of time_key : % -> % not allowed',\n                                                      OLD.time_key, NEW.time_key;\n            END IF;\n\n            delta_time_key = OLD.time_key;\n            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;\n            delta_units_sold = NEW.units_sold - OLD.units_sold;\n            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;\n\n        ELSIF (TG_OP = 'INSERT') THEN\n\n            delta_time_key = NEW.time_key;\n            delta_amount_sold = NEW.amount_sold;\n            delta_units_sold = NEW.units_sold;\n            delta_amount_cost = NEW.amount_cost;\n\n        END IF;\n\n\n        -- Insert or update the summary row with the new values.\n        <<insert_update>>\n        LOOP\n            UPDATE sales_summary_bytime\n                SET amount_sold = amount_sold + delta_amount_sold,\n                    units_sold = units_sold + delta_units_sold,\n                    amount_cost = amount_cost + delta_amount_cost\n                WHERE time_key = delta_time_key;\n\n            EXIT insert_update WHEN found;\n\n            BEGIN\n                INSERT INTO sales_summary_bytime (\n                            time_key,\n                            amount_sold,\n                            units_sold,\n                            amount_cost)\n                    VALUES (\n                            delta_time_key,\n                            delta_amount_sold,\n                            delta_units_sold,\n                            delta_amount_cost\n                           );\n\n                EXIT insert_update;\n\n            EXCEPTION\n                WHEN UNIQUE_VIOLATION THEN\n                    -- do nothing\n            END;\n        END LOOP insert_update;\n\n        RETURN NULL;\n\n    END;\n$maint_sales_summary_bytime$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER maint_sales_summary_bytime\nAFTER INSERT OR UPDATE OR DELETE ON sales_fact\n    FOR EACH ROW EXECUTE FUNCTION maint_sales_summary_bytime();"
  },
  {
    "Query": "INSERT INTO sales_fact VALUES(1,1,1,10,3,15);"
  },
  {
    "Query": "INSERT INTO sales_fact VALUES(1,2,1,20,5,35);"
  },
  {
    "Query": "INSERT INTO sales_fact VALUES(2,2,1,40,15,135);"
  },
  {
    "Query": "INSERT INTO sales_fact VALUES(2,3,1,10,1,13);"
  },
  {
    "Query": "SELECT * FROM sales_summary_bytime;"
  },
  {
    "Query": "DELETE FROM sales_fact WHERE product_key = 1;"
  },
  {
    "Query": "SELECT * FROM sales_summary_bytime;"
  },
  {
    "Query": "UPDATE sales_fact SET units_sold = units_sold * 2;"
  },
  {
    "Query": "SELECT * FROM sales_summary_bytime;"
  },
  {
    "Query": "CREATE TABLE emp (\n    empname           text NOT NULL,\n    salary            integer\n);"
  },
  {
    "Query": "CREATE TABLE emp_audit(\n    operation         char(1)   NOT NULL,\n    stamp             timestamp NOT NULL,\n    userid            text      NOT NULL,\n    empname           text      NOT NULL,\n    salary integer\n);"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$\n    BEGIN\n        --\n        -- Create rows in emp_audit to reflect the operations performed on emp,\n        -- making use of the special variable TG_OP to work out the operation.\n        --\n        IF (TG_OP = 'DELETE') THEN\n            INSERT INTO emp_audit\n                SELECT 'D', now(), user, o.* FROM old_table o;\n        ELSIF (TG_OP = 'UPDATE') THEN\n            INSERT INTO emp_audit\n                SELECT 'U', now(), user, n.* FROM new_table n;\n        ELSIF (TG_OP = 'INSERT') THEN\n            INSERT INTO emp_audit\n                SELECT 'I', now(), user, n.* FROM new_table n;\n        END IF;\n        RETURN NULL; -- result is ignored since this is an AFTER trigger\n    END;\n$emp_audit$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE TRIGGER emp_audit_ins\n    AFTER INSERT ON emp\n    REFERENCING NEW TABLE AS new_table\n    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();"
  },
  {
    "Query": "CREATE TRIGGER emp_audit_upd\n    AFTER UPDATE ON emp\n    REFERENCING OLD TABLE AS old_table NEW TABLE AS new_table\n    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();"
  },
  {
    "Query": "CREATE TRIGGER emp_audit_del\n    AFTER DELETE ON emp\n    REFERENCING OLD TABLE AS old_table\n    FOR EACH STATEMENT EXECUTE FUNCTION process_emp_audit();"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$\nBEGIN\n    RAISE NOTICE 'snitch: % %', tg_event, tg_tag;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE FUNCTION snitch();"
  },
  {
    "Query": "CREATE EXTENSION module_name;"
  },
  {
    "Query": "CREATE TABLE films_recent AS\n  SELECT * FROM films WHERE date_prod >= '2002-01-01';"
  },
  {
    "Query": "CREATE TABLE films2 AS\n  TABLE films;"
  },
  {
    "Query": "PREPARE recentfilms(date) AS\n  SELECT * FROM films WHERE date_prod > $1"
  },
  {
    "Query": "CREATE TEMP TABLE films_recent ON COMMIT DROP AS\n  EXECUTE recentfilms('2002-01-01');"
  },
  {
    "Query": "CREATE DATABASE lusiadas;"
  },
  {
    "Query": "CREATE DATABASE sales OWNER salesapp TABLESPACE salesspace;"
  },
  {
    "Query": "CREATE DATABASE music\n    LOCALE 'sv_SE.utf8'\n    TEMPLATE template0;"
  },
  {
    "Query": "CREATE DATABASE music2\n    LOCALE 'sv_SE.iso885915'\n    ENCODING LATIN9\n    TEMPLATE template0;"
  },
  {
    "Query": "SELECT a, b FROM table1 ORDER BY a + b, c;"
  },
  {
    "Query": "SELECT a + b AS sum, c FROM table1 ORDER BY sum;"
  },
  {
    "Query": "SELECT a, max(b) FROM table1 GROUP BY a ORDER BY 1;"
  },
  {
    "Query": "SELECT a + b AS sum, c FROM table1 ORDER BY sum + c;"
  },
  {
    "Query": "CREATE TABLE reservation (room int, during tsrange);"
  },
  {
    "Query": "INSERT INTO reservation VALUES\n    (1108, '[2010-01-01 14:30, 2010-01-01 15:30)');"
  },
  {
    "Query": "SELECT int4range(10, 20) @> 3;"
  },
  {
    "Query": "SELECT numrange(11.1, 22.2) && numrange(20.0, 30.0);"
  },
  {
    "Query": "SELECT upper(int8range(15, 25));"
  },
  {
    "Query": "SELECT int4range(10, 20) * int4range(15, 25);"
  },
  {
    "Query": "SELECT isempty(numrange(1, 5));"
  },
  {
    "Query": "SELECT '[3,7)'::int4range;"
  },
  {
    "Query": "SELECT '(3,7)'::int4range;"
  },
  {
    "Query": "SELECT '[4,4]'::int4range;"
  },
  {
    "Query": "SELECT '[4,4)'::int4range;"
  },
  {
    "Query": "SELECT numrange(1.0, 14.0, '(]');"
  },
  {
    "Query": "SELECT numrange(1.0, 14.0);"
  },
  {
    "Query": "SELECT int8range(1, 14, '(]');"
  },
  {
    "Query": "SELECT numrange(NULL, 2.2);"
  },
  {
    "Query": "CREATE TYPE floatrange AS RANGE (\n    subtype = float8,\n    subtype_diff = float8mi\n);"
  },
  {
    "Query": "SELECT '[1.234, 5.678]'::floatrange;"
  },
  {
    "Query": "CREATE FUNCTION time_subtype_diff(x time, y time) RETURNS float8 AS\n'SELECT EXTRACT(EPOCH FROM (x - y))' LANGUAGE sql STRICT IMMUTABLE;"
  },
  {
    "Query": "CREATE TYPE timerange AS RANGE (\n    subtype = time,\n    subtype_diff = time_subtype_diff\n);"
  },
  {
    "Query": "SELECT '[11:10, 23:00]'::timerange;"
  },
  {
    "Query": "CREATE INDEX reservation_idx ON reservation USING GIST (during);"
  },
  {
    "Query": "CREATE TABLE reservation (\n    during tsrange,\n    EXCLUDE USING GIST (during WITH &&)\n);"
  },
  {
    "Query": "INSERT INTO reservation VALUES\n    ('[2010-01-01 11:30, 2010-01-01 15:00)');"
  },
  {
    "Query": "CREATE EXTENSION btree_gist;"
  },
  {
    "Query": "CREATE TABLE room_reservation (\n    room text,\n    during tsrange,\n    EXCLUDE USING GIST (room WITH =, during WITH &&)\n);"
  },
  {
    "Query": "INSERT INTO room_reservation VALUES\n    ('123A', '[2010-01-01 14:00, 2010-01-01 15:00)');"
  },
  {
    "Query": "INSERT INTO room_reservation VALUES\n    ('123B', '[2010-01-01 14:30, 2010-01-01 15:30)')"
  },
  {
    "Query": "DROP SEQUENCE serial;"
  },
  {
    "Query": "COMMIT;"
  },
  {
    "Query": "DROP OPERATOR CLASS widget_ops USING btree;"
  },
  {
    "Query": "SELECT agg(col) FROM tab;"
  },
  {
    "Query": "CREATE USER rewind_user LOGIN;"
  },
  {
    "Query": "GRANT EXECUTE ON function pg_catalog.pg_ls_dir(text, boolean, boolean) TO rewind_user;"
  },
  {
    "Query": "GRANT EXECUTE ON function pg_catalog.pg_stat_file(text, boolean) TO rewind_user;"
  },
  {
    "Query": "GRANT EXECUTE ON function pg_catalog.pg_read_binary_file(text) TO rewind_user;"
  },
  {
    "Query": "GRANT EXECUTE ON function pg_catalog.pg_read_binary_file(text, bigint, bigint, boolean) TO rewind_user;"
  },
  {
    "Query": "CREATE TEXT SEARCH CONFIGURATION public.pg ( COPY = pg_catalog.english );"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY pg_dict (\n    TEMPLATE = synonym,\n    SYNONYMS = pg_dict\n);"
  },
  {
    "Query": "CREATE TEXT SEARCH DICTIONARY english_ispell (\n    TEMPLATE = ispell,\n    DictFile = english,\n    AffFile = english,\n    StopWords = english\n);"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION pg\n    ALTER MAPPING FOR asciiword, asciihword, hword_asciipart,\n                      word, hword, hword_part\n    WITH pg_dict, english_ispell, english_stem;"
  },
  {
    "Query": "ALTER TEXT SEARCH CONFIGURATION pg\n    DROP MAPPING FOR email, url, url_path, sfloat, float;"
  },
  {
    "Query": "SELECT * FROM ts_debug('public.pg', '\nPostgreSQL, the highly scalable, SQL compliant, open source object-relational\ndatabase management system, is now undergoing beta testing of the next\nversion of our software.\n');"
  },
  {
    "Query": "ALTER TEXT SEARCH DICTIONARY my_dict ( StopWords = newrussian );"
  },
  {
    "Query": "ALTER TEXT SEARCH DICTIONARY my_dict ( language = dutch, StopWords );"
  },
  {
    "Query": "ALTER TEXT SEARCH DICTIONARY my_dict ( dummy );"
  },
  {
    "Query": "DROP PROCEDURE do_db_maintenance();"
  },
  {
    "Query": "TRUNCATE bigtable, fattable;"
  },
  {
    "Query": "TRUNCATE bigtable, fattable RESTART IDENTITY;"
  },
  {
    "Query": "TRUNCATE othertable CASCADE;"
  },
  {
    "Query": "CREATE FUNCTION plperl_call_handler() RETURNS language_handler AS\n    '$libdir/plperl' LANGUAGE C;"
  },
  {
    "Query": "CREATE FUNCTION plperl_inline_handler(internal) RETURNS void AS\n    '$libdir/plperl' LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE FUNCTION plperl_validator(oid) RETURNS void AS\n    '$libdir/plperl' LANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE TRUSTED LANGUAGE plperl\n    HANDLER plperl_call_handler\n    INLINE plperl_inline_handler\n    VALIDATOR plperl_validator;"
  },
  {
    "Query": "SELECT * FROM generate_series(2,4);"
  },
  {
    "Query": "SELECT * FROM generate_series(5,1,-2)"
  },
  {
    "Query": "SELECT * FROM generate_series(4,3)"
  },
  {
    "Query": "SELECT generate_series(1.1, 4, 1.3)"
  },
  {
    "Query": "SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a)"
  },
  {
    "Query": "SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n                              '2008-03-04 12:00', '10 hours')"
  },
  {
    "Query": "SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;"
  },
  {
    "Query": "SELECT * FROM arrays"
  },
  {
    "Query": "SELECT a AS array, s AS subscript, a[s] AS value\nFROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION unnest2(anyarray)\nRETURNS SETOF anyelement AS $$\nselect $1[i][j]\n   from generate_subscripts($1,1) g1(i),\n        generate_subscripts($1,2) g2(j)"
  },
  {
    "Query": "SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);"
  },
  {
    "Query": "SELECT SESSION_USER, CURRENT_USER;"
  },
  {
    "Query": "SET ROLE 'paul'"
  },
  {
    "Query": "SELECT SESSION_USER, CURRENT_USER;"
  },
  {
    "Query": "SELECT * INTO myrec FROM emp WHERE empname = myname;"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "CREATE FUNCTION get_userid(username text) RETURNS int\nAS $$\n#print_strict_params on\nDECLARE\nuserid int;\nBEGIN\n    SELECT users.userid INTO STRICT userid\n        FROM users WHERE users.username = get_userid.username;\n    RETURN userid;\nEND;\n$$ LANGUAGE plpgsql;"
  },
  {
    "Query": "EXECUTE format('UPDATE tbl SET %I = %L '\n   'WHERE key = %L', colname, newvalue, keyvalue)"
  },
  {
    "Query": "END;"
  },
  {
    "Query": "ALTER TYPE electronic_mail RENAME TO email;"
  },
  {
    "Query": "ALTER TYPE email OWNER TO joe;"
  },
  {
    "Query": "ALTER TYPE email SET SCHEMA customers;"
  },
  {
    "Query": "ALTER TYPE compfoo ADD ATTRIBUTE f3 int;"
  },
  {
    "Query": "ALTER TYPE colors ADD VALUE 'orange' AFTER 'red';"
  },
  {
    "Query": "ALTER TYPE colors RENAME VALUE 'purple' TO 'mauve';"
  },
  {
    "Query": "ALTER TYPE mytype SET (\n    SEND = mytypesend,\n    RECEIVE = mytyperecv\n);"
  },
  {
    "Query": "ALTER SUBSCRIPTION mysub SET PUBLICATION insert_only;"
  },
  {
    "Query": "ALTER SUBSCRIPTION mysub DISABLE;"
  },
  {
    "Query": "ALTER TABLE products ADD COLUMN description text;"
  },
  {
    "Query": "ALTER TABLE products ADD COLUMN description text CHECK (description <> '');"
  },
  {
    "Query": "ALTER TABLE products DROP COLUMN description;"
  },
  {
    "Query": "ALTER TABLE products DROP COLUMN description CASCADE;"
  },
  {
    "Query": "ALTER TABLE products ADD CHECK (name <> '');"
  },
  {
    "Query": "ALTER TABLE products ADD CONSTRAINT some_name UNIQUE (product_no);"
  },
  {
    "Query": "ALTER TABLE products ADD FOREIGN KEY (product_group_id) REFERENCES product_groups;"
  },
  {
    "Query": "ALTER TABLE products ALTER COLUMN product_no SET NOT NULL;"
  },
  {
    "Query": "ALTER TABLE products DROP CONSTRAINT some_name;"
  },
  {
    "Query": "ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;"
  },
  {
    "Query": "ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;"
  },
  {
    "Query": "ALTER TABLE products ALTER COLUMN price DROP DEFAULT;"
  },
  {
    "Query": "ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);"
  },
  {
    "Query": "ALTER TABLE products RENAME COLUMN product_no TO product_number;"
  },
  {
    "Query": "ALTER TABLE products RENAME TO items;"
  },
  {
    "Query": "CREATE FUNCTION square_root(double precision) RETURNS double precision\n    AS 'dsqrt'\n    LANGUAGE internal\n    STRICT;"
  },
  {
    "Query": "DROP FUNCTION sqrt(integer);"
  },
  {
    "Query": "DROP FUNCTION sqrt(integer), sqrt(bigint);"
  },
  {
    "Query": "DROP FUNCTION update_employee_salaries;"
  },
  {
    "Query": "DROP FUNCTION update_employee_salaries();"
  },
  {
    "Query": "REVOKE INSERT ON films FROM PUBLIC;"
  },
  {
    "Query": "REVOKE ALL PRIVILEGES ON kinds FROM manuel;"
  },
  {
    "Query": "REVOKE admins FROM joe;"
  },
  {
    "Query": "CREATE FUNCTION transfer_funds() RETURNS void AS $$\n    if [catch {\n        spi_exec \"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\"\n        spi_exec \"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\"\n    } errormsg] {\n        set result [format \"error transferring funds: %s\" $errormsg]\n    } else {\n        set result \"funds transferred successfully\"\n    }\n    spi_exec \"INSERT INTO operations (result) VALUES ('[quote $result]')\"\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE FUNCTION transfer_funds2() RETURNS void AS $$\n    if [catch {\n        subtransaction {\n            spi_exec \"UPDATE accounts SET balance = balance - 100 WHERE account_name = 'joe'\"\n            spi_exec \"UPDATE accounts SET balance = balance + 100 WHERE account_name = 'mary'\"\n        }\n    } errormsg] {\n        set result [format \"error transferring funds: %s\" $errormsg]\n    } else {\n        set result \"funds transferred successfully\"\n    }\n    spi_exec \"INSERT INTO operations (result) VALUES ('[quote $result]')\"\n$$ LANGUAGE pltcl;"
  },
  {
    "Query": "CREATE FUNCTION pymax (a integer, b integer)\n  RETURNS integer\nAS $$\n  if (a is None) or (b is None):\n    return None\n  if a > b:\n    return a\n  return b\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION return_arr()\n  RETURNS int[]\nAS $$\nreturn [1, 2, 3, 4, 5]\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "SELECT return_arr();"
  },
  {
    "Query": "CREATE FUNCTION test_type_conversion_array_int4(x int4[]) RETURNS int4[] AS $$\nplpy.info(x, type(x))\nreturn x\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "SELECT * FROM test_type_conversion_array_int4(ARRAY[[1,2,3],[4,5,6]]);"
  },
  {
    "Query": "CREATE FUNCTION return_str_arr()\n  RETURNS varchar[]\nAS $$\nreturn \"hello\"\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "SELECT return_str_arr();"
  },
  {
    "Query": "CREATE TABLE employee (\n  name text,\n  salary integer,\n  age integer\n);"
  },
  {
    "Query": "CREATE FUNCTION overpaid (e employee)\n  RETURNS boolean\nAS $$\n  if e[\"salary\"] > 200000:\n    return True\n  if (e[\"age\"] < 30) and (e[\"salary\"] > 100000):\n    return True\n  return False\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE TYPE named_value AS (\n  name   text,\n  value  integer\n);"
  },
  {
    "Query": "CREATE FUNCTION make_pair (name text, value integer)\n  RETURNS named_value\nAS $$\n  return ( name, value )\n  # or alternatively, as list: return [ name, value ]\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION make_pair (name text, value integer)\n  RETURNS named_value\nAS $$\n  return { \"name\": name, \"value\": value }\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION make_pair (name text, value integer)\n  RETURNS named_value\nAS $$\n  class named_value:\n    def __init__ (self, n, v):\n      self.name = n\n      self.value = v\n  return named_value(name, value)\n\n  # or simply\n  class nv: pass\n  nv.name = name\n  nv.value = value\n  return nv\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION multiout_simple(OUT i integer, OUT j integer) AS $$\nreturn (1, 2)\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "SELECT * FROM multiout_simple();"
  },
  {
    "Query": "CREATE PROCEDURE python_triple(INOUT a integer, INOUT b integer) AS $$\nreturn (a * 3, b * 3)\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CALL python_triple(5, 10);"
  },
  {
    "Query": "CREATE TYPE greeting AS (\n  how text,\n  who text\n);"
  },
  {
    "Query": "CREATE FUNCTION greet (how text)\n  RETURNS SETOF greeting\nAS $$\n  # return tuple containing lists as composite types\n  # all other combinations work also\n  return ( [ how, \"World\" ], [ how, \"PostgreSQL\" ], [ how, \"PL/Python\" ] )\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION greet (how text)\n  RETURNS SETOF greeting\nAS $$\n  class producer:\n    def __init__ (self, how, who):\n      self.how = how\n      self.who = who\n      self.ndx = -1\n\n    def __iter__ (self):\n      return self\n\n    def next (self):\n      self.ndx += 1\n      if self.ndx == len(self.who):\n        raise StopIteration\n      return ( self.how, self.who[self.ndx] )\n\n  return producer(how, [ \"World\", \"PostgreSQL\", \"PL/Python\" ])\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION greet (how text)\n  RETURNS SETOF greeting\nAS $$\n  for who in [ \"World\", \"PostgreSQL\", \"PL/Python\" ]:\n    yield ( how, who )\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION multiout_simple_setof(n integer, OUT integer, OUT integer) RETURNS SETOF record AS $$\nreturn [(1, 2)] * n\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "SELECT * FROM multiout_simple_setof(3);"
  },
  {
    "Query": "SELECT max(temp_lo) FROM weather;"
  },
  {
    "Query": "SELECT city FROM weather WHERE temp_lo = max(temp_lo);"
  },
  {
    "Query": "SELECT city FROM weather\n    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);"
  },
  {
    "Query": "SELECT city, max(temp_lo)\n    FROM weather\n    GROUP BY city;"
  },
  {
    "Query": "SELECT city, max(temp_lo), count(*) FILTER (WHERE temp_lo < 30)\n    FROM weather\n    GROUP BY city\n    HAVING max(temp_lo) < 40;"
  },
  {
    "Query": "SELECT city, max(temp_lo), count(*) FILTER (WHERE temp_lo < 30)\n    FROM weather\n    WHERE city LIKE 'S%'\nGROUP BY city\n    HAVING max(temp_lo) < 40;"
  },
  {
    "Query": "ALTER RULE notify_all ON emp RENAME TO notify_me;"
  },
  {
    "Query": "SELECT * FROM pg_create_physical_replication_slot('node_a_slot');"
  },
  {
    "Query": "SELECT slot_name, slot_type, active FROM pg_replication_slots"
  },
  {
    "Query": "WITH regional_sales AS (\n    SELECT region, SUM(amount) AS total_sales\n    FROM orders\n    GROUP BY region\n), top_regions AS (\n    SELECT region\n    FROM regional_sales\n    WHERE total_sales > (SELECT SUM(total_sales)/10 FROM regional_sales)\n)\nSELECT region,\n       product,\n       SUM(quantity) AS product_units,\n       SUM(amount) AS product_sales\nFROM orders\nWHERE region IN (SELECT region FROM top_regions)\nGROUP BY region, product;"
  },
  {
    "Query": "WITH RECURSIVE t(n) AS (\n    VALUES (1)\n  UNION ALL\n    SELECT n+1 FROM t WHERE n < 100\n)\nSELECT sum(n) FROM t"
  },
  {
    "Query": "WITH RECURSIVE included_parts(sub_part, part, quantity) AS (\n    SELECT sub_part, part, quantity FROM parts WHERE part = 'our_product'\n  UNION ALL\n    SELECT p.sub_part, p.part, p.quantity * pr.quantity\n    FROM included_parts pr, parts p\n    WHERE p.part = pr.sub_part\n)\nSELECT sub_part, SUM(quantity) as total_quantity\nFROM included_parts\nGROUP BY sub_part"
  },
  {
    "Query": "WITH RECURSIVE search_graph(id, link, data, depth) AS (\n    SELECT g.id, g.link, g.data, 1\n    FROM graph g\n  UNION ALL\n    SELECT g.id, g.link, g.data, sg.depth + 1\n    FROM graph g, search_graph sg\n    WHERE g.id = sg.link\n)\nSELECT * FROM search_graph"
  },
  {
    "Query": "WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n    SELECT g.id, g.link, g.data, 1,\n      ARRAY[g.id],\n      false\n    FROM graph g\n  UNION ALL\n    SELECT g.id, g.link, g.data, sg.depth + 1,\n      path || g.id,\n      g.id = ANY(path)\n    FROM graph g, search_graph sg\n    WHERE g.id = sg.link AND NOT cycle\n)\nSELECT * FROM search_graph"
  },
  {
    "Query": "WITH RECURSIVE search_graph(id, link, data, depth, path, cycle) AS (\n    SELECT g.id, g.link, g.data, 1,\n      ARRAY[ROW(g.f1, g.f2)],\n      false\n    FROM graph g\n  UNION ALL\n    SELECT g.id, g.link, g.data, sg.depth + 1,\n      path || ROW(g.f1, g.f2),\n      ROW(g.f1, g.f2) = ANY(path)\n    FROM graph g, search_graph sg\n    WHERE g.id = sg.link AND NOT cycle\n)\nSELECT * FROM search_graph"
  },
  {
    "Query": "WITH RECURSIVE t(n) AS (\n    SELECT 1\n  UNION ALL\n    SELECT n+1 FROM t\n)\nSELECT n FROM t LIMIT 100"
  },
  {
    "Query": "WITH w AS (\n    SELECT * FROM big_table\n)\nSELECT * FROM w WHERE key = 123;"
  },
  {
    "Query": "SELECT * FROM big_table WHERE key = 123;"
  },
  {
    "Query": "WITH w AS (\n    SELECT * FROM big_table\n)\nSELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref\nWHERE w2.key = 123;"
  },
  {
    "Query": "WITH w AS NOT MATERIALIZED (\n    SELECT * FROM big_table\n)\nSELECT * FROM w AS w1 JOIN w AS w2 ON w1.key = w2.ref\nWHERE w2.key = 123"
  },
  {
    "Query": "WITH w AS (\n    SELECT key, very_expensive_function(val) as f FROM some_table\n)\nSELECT * FROM w AS w1 JOIN w AS w2 ON w1.f = w2.f;"
  },
  {
    "Query": "WITH moved_rows AS (\n    DELETE FROM products\n    WHERE\n        \"date\" >= '2010-10-01' AND\n        \"date\" < '2010-11-01'\n    RETURNING *\n)\nINSERT INTO products_log\nSELECT * FROM moved_rows;"
  },
  {
    "Query": "WITH t AS (\n    DELETE FROM foo\n)\nDELETE FROM bar;"
  },
  {
    "Query": "WITH RECURSIVE included_parts(sub_part, part) AS (\n    SELECT sub_part, part FROM parts WHERE part = 'our_product'\n  UNION ALL\n    SELECT p.sub_part, p.part\n    FROM included_parts pr, parts p\n    WHERE p.part = pr.sub_part\n)\nDELETE FROM parts\n  WHERE part IN (SELECT part FROM included_parts)"
  },
  {
    "Query": "WITH t AS (\n    UPDATE products SET price = price * 1.05\n    RETURNING *\n)\nSELECT * FROM products;"
  },
  {
    "Query": "WITH t AS (\n    UPDATE products SET price = price * 1.05\n    RETURNING *\n)\nSELECT * FROM t;"
  },
  {
    "Query": "DROP FOREIGN DATA WRAPPER dbi;"
  },
  {
    "Query": "CREATE TABLE t3 (\n    ii integer[]\n);"
  },
  {
    "Query": "SELECT * FROM t3;"
  },
  {
    "Query": "CREATE TYPE comp_t AS (intval integer, textval varchar(32));"
  },
  {
    "Query": "CREATE TABLE t4 (compval comp_t);"
  },
  {
    "Query": "INSERT INTO t4 VALUES ( (256, 'PostgreSQL') );"
  },
  {
    "Query": "CREATE FUNCTION create_complex(r double, i double) RETURNS complex\nLANGUAGE SQL\nIMMUTABLE\nAS $$ SELECT $1 * complex '(1,0')' + $2 * complex '(0,1)' $$;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION perlsnitch() RETURNS event_trigger AS $$\n  elog(NOTICE, \"perlsnitch: \" . $_TD->{event} . \" \" . $_TD->{tag} . \" \");\n$$ LANGUAGE plperl;"
  },
  {
    "Query": "CREATE EVENT TRIGGER perl_a_snitch\n    ON ddl_command_start\n    EXECUTE FUNCTION perlsnitch();"
  },
  {
    "Query": "SELECT *\n    FROM weather, cities\n    WHERE city = name;"
  },
  {
    "Query": "SELECT city, temp_lo, temp_hi, prcp, date, location\n    FROM weather, cities\n    WHERE city = name;"
  },
  {
    "Query": "SELECT weather.city, weather.temp_lo, weather.temp_hi,\n       weather.prcp, weather.date, cities.location\n    FROM weather, cities\n    WHERE cities.name = weather.city;"
  },
  {
    "Query": "SELECT *\n    FROM weather INNER JOIN cities ON (weather.city = cities.name);"
  },
  {
    "Query": "SELECT *\n    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);"
  },
  {
    "Query": "SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,\n    W2.city, W2.temp_lo AS low, W2.temp_hi AS high\n    FROM weather W1, weather W2\n    WHERE W1.temp_lo < W2.temp_lo\n    AND W1.temp_hi > W2.temp_hi;"
  },
  {
    "Query": "SELECT *\n    FROM weather w, cities c\n    WHERE w.city = c.name;"
  },
  {
    "Query": "CREATE FUNCTION plsample_call_handler() RETURNS language_handler\n    AS 'filename'\n    LANGUAGE C;"
  },
  {
    "Query": "CREATE LANGUAGE plsample\n    HANDLER plsample_call_handler;"
  },
  {
    "Query": "LISTEN virtual;"
  },
  {
    "Query": "NOTIFY virtual;"
  },
  {
    "Query": "NOTIFY virtual, 'This is the payload'"
  },
  {
    "Query": "LISTEN foo"
  },
  {
    "Query": "SELECT pg_notify('fo' || 'o', 'pay' || 'load');"
  },
  {
    "Query": "CREATE FUNCTION plsample_call_handler() RETURNS language_handler\n    AS '$libdir/plsample'\n    LANGUAGE C;"
  },
  {
    "Query": "CREATE LANGUAGE plsample\n    HANDLER plsample_call_handler;"
  },
  {
    "Query": "CREATE EXTENSION plsample;"
  },
  {
    "Query": "DELETE FROM products WHERE price = 10;"
  },
  {
    "Query": "DELETE FROM products;"
  },
  {
    "Query": "SELECT dblink_error_message('dtest1');"
  },
  {
    "Query": "CREATE TRIGGER check_update\n    BEFORE UPDATE ON accounts\n    FOR EACH ROW\n    EXECUTE FUNCTION check_account_update();"
  },
  {
    "Query": "CREATE TRIGGER check_update\n    BEFORE UPDATE OF balance ON accounts\n    FOR EACH ROW\n    EXECUTE FUNCTION check_account_update();"
  },
  {
    "Query": "CREATE TRIGGER check_update\n    BEFORE UPDATE ON accounts\n    FOR EACH ROW\n    WHEN (OLD.balance IS DISTINCT FROM NEW.balance)\n    EXECUTE FUNCTION check_account_update();"
  },
  {
    "Query": "CREATE TRIGGER log_update\n    AFTER UPDATE ON accounts\n    FOR EACH ROW\n    WHEN (OLD.* IS DISTINCT FROM NEW.*)\n    EXECUTE FUNCTION log_account_update();"
  },
  {
    "Query": "CREATE TRIGGER view_insert\n    INSTEAD OF INSERT ON my_view\n    FOR EACH ROW\n    EXECUTE FUNCTION view_insert_row();"
  },
  {
    "Query": "CREATE TRIGGER transfer_insert\n    AFTER INSERT ON transfer\n    REFERENCING NEW TABLE AS inserted\n    FOR EACH STATEMENT\n    EXECUTE FUNCTION check_transfer_balances_to_zero();"
  },
  {
    "Query": "CREATE TRIGGER paired_items_update\n    AFTER UPDATE ON paired_items\n    REFERENCING NEW TABLE AS newtab OLD TABLE AS oldtab\n    FOR EACH ROW\n    EXECUTE FUNCTION check_matching_pairs();"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_options(internal)\nRETURNS void\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "ALTER TABLE user_catalog_table SET (user_catalog_table = true);"
  },
  {
    "Query": "CREATE TABLE another_catalog_table(data text) WITH (user_catalog_table = true);"
  },
  {
    "Query": "REFRESH MATERIALIZED VIEW order_summary;"
  },
  {
    "Query": "REFRESH MATERIALIZED VIEW annual_statistics_basis WITH NO DATA;"
  },
  {
    "Query": "DROP INDEX title_idx;"
  },
  {
    "Query": "SELECT x,\n  round(x::numeric) AS num_round,\n  round(x::double precision) AS dbl_round\nFROM generate_series(-3.5, 3.5, 1) as x;"
  },
  {
    "Query": "CREATE TABLE tablename (\n    colname SERIAL\n);"
  },
  {
    "Query": "CREATE SEQUENCE tablename_colname_seq AS integer;"
  },
  {
    "Query": "CREATE TABLE tablename (\n    colname integer NOT NULL DEFAULT nextval('tablename_colname_seq')\n);"
  },
  {
    "Query": "ALTER SEQUENCE tablename_colname_seq OWNED BY tablename.colname;"
  },
  {
    "Query": "CREATE SUBSCRIPTION mysub\n         CONNECTION 'host=192.168.1.50 port=5432 user=foo dbname=foodb'\n        PUBLICATION mypublication, insert_only;"
  },
  {
    "Query": "CREATE SUBSCRIPTION mysub\n         CONNECTION 'host=192.168.1.50 port=5432 user=foo dbname=foodb'\n        PUBLICATION insert_only\n               WITH (enabled = false);"
  },
  {
    "Query": "SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;"
  },
  {
    "Query": "SELECT * FROM pg_attribute\n  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');"
  },
  {
    "Query": "CREATE OPERATOR === (\n    LEFTARG = box,\n    RIGHTARG = box,\n    FUNCTION = area_equal_function,\n    COMMUTATOR = ===,\n    NEGATOR = !==,\n    RESTRICT = area_restriction_function,\n    JOIN = area_join_function,\n    HASHES, MERGES\n);"
  },
  {
    "Query": "CREATE ROLE jonathan LOGIN;"
  },
  {
    "Query": "CREATE USER davide WITH PASSWORD 'jw8s0F4';"
  },
  {
    "Query": "CREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';"
  },
  {
    "Query": "CREATE ROLE admin WITH CREATEDB CREATEROLE;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_consistent(internal, data_type, smallint, oid, internal)\nRETURNS bool\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_union(internal, internal)\nRETURNS storage_type\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_compress(internal)\nRETURNS internal\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_decompress(internal)\nRETURNS internal\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_penalty(internal, internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_picksplit(internal, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_same(storage_type, storage_type, internal)\nRETURNS internal\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_distance(internal, data_type, smallint, oid, internal)\nRETURNS float8\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_fetch(internal)\nRETURNS internal\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION my_options(internal)\nRETURNS void\nAS 'MODULE_PATHNAME'\nLANGUAGE C STRICT;"
  },
  {
    "Query": "SELECT * FROM weather;"
  },
  {
    "Query": "SELECT city, temp_lo, temp_hi, prcp, date FROM weather;"
  },
  {
    "Query": "SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;"
  },
  {
    "Query": "SELECT * FROM weather\n    WHERE city = 'San Francisco' AND prcp > 0.0;"
  },
  {
    "Query": "SELECT * FROM weather\n    ORDER BY city;"
  },
  {
    "Query": "SELECT * FROM weather\n    ORDER BY city, temp_lo;"
  },
  {
    "Query": "SELECT DISTINCT city\n    FROM weather;"
  },
  {
    "Query": "SELECT DISTINCT city\n    FROM weather\n    ORDER BY city;"
  },
  {
    "Query": "SELECT CAST(42 AS float8);"
  },
  {
    "Query": "INSERT INTO foo (f1) VALUES (42);"
  },
  {
    "Query": "SELECT 2 + 4.0;"
  },
  {
    "Query": "SELECT CAST ( 2 AS numeric ) + 4.0;"
  },
  {
    "Query": "CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;"
  },
  {
    "Query": "COPY country TO STDOUT (DELIMITER '|');"
  },
  {
    "Query": "COPY country FROM '/usr1/proj/bray/sql/country_data';"
  },
  {
    "Query": "COPY (SELECT * FROM country WHERE country_name LIKE 'A%') TO '/usr1/proj/bray/sql/a_list_countries.copy';"
  },
  {
    "Query": "COPY country TO PROGRAM 'gzip > /usr1/proj/bray/sql/country_data.gz';"
  },
  {
    "Query": "DROP COLLATION german;"
  },
  {
    "Query": "DROP EXTENSION hstore;"
  },
  {
    "Query": "DROP SERVER IF EXISTS foo;"
  },
  {
    "Query": "SELECT a < 'foo' FROM test1;"
  },
  {
    "Query": "SELECT a < ('foo' COLLATE \"fr_FR\") FROM test1;"
  },
  {
    "Query": "SELECT a < b FROM test1;"
  },
  {
    "Query": "SELECT a < b COLLATE \"de_DE\" FROM test1;"
  },
  {
    "Query": "SELECT a COLLATE \"de_DE\" < b FROM test1;"
  },
  {
    "Query": "SELECT a || b FROM test1;"
  },
  {
    "Query": "SELECT * FROM test1 ORDER BY a || 'foo';"
  },
  {
    "Query": "SELECT * FROM test1 ORDER BY a || b;"
  },
  {
    "Query": "SELECT * FROM test1 ORDER BY a || b COLLATE \"fr_FR\";"
  },
  {
    "Query": "SELECT a COLLATE \"C\" < b COLLATE \"POSIX\" FROM test1;"
  },
  {
    "Query": "CREATE COLLATION german (provider = libc, locale = 'de_DE');"
  },
  {
    "Query": "CREATE COLLATION german FROM \"de_DE\";"
  },
  {
    "Query": "CREATE COLLATION french FROM \"fr-x-icu\";"
  },
  {
    "Query": "CREATE COLLATION ndcoll (provider = icu, locale = 'und', deterministic = false);"
  },
  {
    "Query": "CREATE COLLATION case_insensitive (provider = icu, locale = 'und-u-ks-level2', deterministic = false);"
  },
  {
    "Query": "CREATE COLLATION ignore_accents (provider = icu, locale = 'und-u-ks-level1-kc-true', deterministic = false);"
  },
  {
    "Query": "BEGIN WORK;"
  },
  {
    "Query": "LOCK TABLE films IN SHARE MODE;"
  },
  {
    "Query": "SELECT id FROM films\n    WHERE name = 'Star Wars: Episode I - The Phantom Menace';"
  },
  {
    "Query": "INSERT INTO films_user_comments VALUES\n    (_id_, 'GREAT! I was waiting for it for so long!');"
  },
  {
    "Query": "COMMIT WORK;"
  },
  {
    "Query": "BEGIN WORK;"
  },
  {
    "Query": "LOCK TABLE films IN SHARE ROW EXCLUSIVE MODE;"
  },
  {
    "Query": "DELETE FROM films_user_comments WHERE id IN\n    (SELECT id FROM films WHERE rating < 5);"
  },
  {
    "Query": "DELETE FROM films WHERE rating < 5;"
  },
  {
    "Query": "COMMIT WORK;"
  },
  {
    "Query": "CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$\n    SELECT encode(digest($1, 'sha1'), 'hex')\n$$ LANGUAGE SQL STRICT IMMUTABLE;"
  },
  {
    "Query": "BEGIN"
  },
  {
    "Query": "END"
  },
  {
    "Query": "SELECT 'a fat cat sat on a mat and ate a fat rat'::tsvector;"
  },
  {
    "Query": "SELECT $$the lexeme '    ' contains spaces$$::tsvector;"
  },
  {
    "Query": "SELECT $$the lexeme 'Joe''s' contains a quote$$::tsvector;"
  },
  {
    "Query": "SELECT 'a:1 fat:2 cat:3 sat:4 on:5 a:6 mat:7 and:8 ate:9 a:10 fat:11 rat:12'::tsvector;"
  },
  {
    "Query": "SELECT 'a:1A fat:2B,4C cat:5D'::tsvector;"
  },
  {
    "Query": "SELECT 'The Fat Rats'::tsvector;"
  },
  {
    "Query": "SELECT to_tsvector('english', 'The Fat Rats');"
  },
  {
    "Query": "SELECT 'fat & rat'::tsquery;"
  },
  {
    "Query": "SELECT 'fat & (rat | cat)'::tsquery"
  },
  {
    "Query": "SELECT 'fat & rat & ! cat'::tsquery"
  },
  {
    "Query": "SELECT 'fat:ab & cat'::tsquery;"
  },
  {
    "Query": "SELECT 'super:*'::tsquery;"
  },
  {
    "Query": "SELECT to_tsquery('Fat:ab & Cats');"
  },
  {
    "Query": "SELECT to_tsvector( 'postgraduate' ) @@ to_tsquery( 'postgres:*' );"
  },
  {
    "Query": "SELECT to_tsvector( 'postgraduate' ), to_tsquery( 'postgres:*' );"
  },
  {
    "Query": "CREATE DATABASE foo WITH TEMPLATE template0;"
  },
  {
    "Query": "CREATE RULE \"_RETURN\" AS\n    ON SELECT TO t1\n    DO INSTEAD\n        SELECT * FROM t2;"
  },
  {
    "Query": "CREATE RULE \"_RETURN\" AS\n    ON SELECT TO t2\n    DO INSTEAD\n        SELECT * FROM t1;"
  },
  {
    "Query": "SELECT * FROM t1;"
  },
  {
    "Query": "CREATE RULE notify_me AS ON UPDATE TO mytable DO ALSO NOTIFY mytable;"
  },
  {
    "Query": "UPDATE mytable SET name = 'foo' WHERE id = 42;"
  },
  {
    "Query": "EXPLAIN EXECUTE name(parameter_values);"
  },
  {
    "Query": "PREPARE fooplan (int, text, bool, numeric) AS\n    INSERT INTO foo VALUES($1, $2, $3, $4)"
  },
  {
    "Query": "EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);"
  },
  {
    "Query": "PREPARE usrrptplan (int) AS\n    SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid\n    AND l.date = $2"
  },
  {
    "Query": "EXECUTE usrrptplan(1, current_date);"
  },
  {
    "Query": "SELECT macaddr8_set7bit('08:00:2b:01:02:03');"
  },
  {
    "Query": "CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__intbig_ops (siglen = 32));"
  },
  {
    "Query": "SELECT message.mid FROM message WHERE message.sections && '{1,2}';"
  },
  {
    "Query": "SELECT message.mid FROM message WHERE message.sections @> '{1,2}';"
  },
  {
    "Query": "SELECT message.mid FROM message WHERE message.sections @@ '1&2'::query_int;"
  },
  {
    "Query": "CREATE INDEX test_index ON test_table (col varchar_pattern_ops);"
  },
  {
    "Query": "SELECT am.amname AS index_method,\n       opc.opcname AS opclass_name,\n       opc.opcintype::regtype AS indexed_type,\n       opc.opcdefault AS is_default\n    FROM pg_am am, pg_opclass opc\n    WHERE opc.opcmethod = am.oid\n    ORDER BY index_method, opclass_name;"
  },
  {
    "Query": "SELECT am.amname AS index_method,\n       opc.opcname AS opclass_name,\n       opf.opfname AS opfamily_name,\n       opc.opcintype::regtype AS indexed_type,\n       opc.opcdefault AS is_default\n    FROM pg_am am, pg_opclass opc, pg_opfamily opf\n    WHERE opc.opcmethod = am.oid AND\n          opc.opcfamily = opf.oid\n    ORDER BY index_method, opclass_name;"
  },
  {
    "Query": "SELECT am.amname AS index_method,\n       opf.opfname AS opfamily_name,\n       amop.amopopr::regoperator AS opfamily_operator\n    FROM pg_am am, pg_opfamily opf, pg_amop amop\n    WHERE opf.opfmethod = am.oid AND\n          amop.amopfamily = opf.oid\n    ORDER BY index_method, opfamily_name, opfamily_operator;"
  },
  {
    "Query": "GRANT pg_signal_backend TO admin_user;"
  },
  {
    "Query": "CREATE FUNCTION pymax (a integer, b integer)\n  RETURNS integer\nAS $$\n  if a > b:\n    return a\n  return b\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION pystrip(x text)\n  RETURNS text\nAS $$\n  x = x.strip()  # error\n  return x\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE FUNCTION pystrip(x text)\n  RETURNS text\nAS $$\n  global x\n  x = x.strip()  # ok now\n  return x\n$$ LANGUAGE plpythonu;"
  },
  {
    "Query": "CREATE STATISTICS stts (dependencies) ON city, zip FROM zipcodes;"
  },
  {
    "Query": "ANALYZE zipcodes;"
  },
  {
    "Query": "SELECT stxname, stxkeys, stxddependencies\n  FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid)\n  WHERE stxname = 'stts';"
  },
  {
    "Query": "SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '94105';"
  },
  {
    "Query": "SELECT * FROM zipcodes WHERE city = 'San Francisco' AND zip = '90210';"
  },
  {
    "Query": "CREATE STATISTICS stts2 (ndistinct) ON city, state, zip FROM zipcodes;"
  },
  {
    "Query": "ANALYZE zipcodes;"
  },
  {
    "Query": "SELECT stxkeys AS k, stxdndistinct AS nd\n  FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid)\n  WHERE stxname = 'stts2';"
  },
  {
    "Query": "CREATE STATISTICS stts3 (mcv) ON city, state FROM zipcodes;"
  },
  {
    "Query": "ANALYZE zipcodes;"
  },
  {
    "Query": "SELECT m.* FROM pg_statistic_ext join pg_statistic_ext_data on (oid = stxoid),\n                pg_mcv_list_items(stxdmcv) m WHERE stxname = 'stts3';"
  },
  {
    "Query": "ALTER FUNCTION sqrt(integer) RENAME TO square_root;"
  },
  {
    "Query": "ALTER FUNCTION sqrt(integer) OWNER TO joe;"
  },
  {
    "Query": "ALTER FUNCTION sqrt(integer) SET SCHEMA maths;"
  },
  {
    "Query": "ALTER FUNCTION sqrt(integer) DEPENDS ON EXTENSION mathlib;"
  },
  {
    "Query": "ALTER FUNCTION check_password(text) SET search_path = admin, pg_temp;"
  },
  {
    "Query": "ALTER FUNCTION check_password(text) RESET search_path;"
  },
  {
    "Query": "CREATE FOREIGN TABLE films (\n    code        char(5) NOT NULL,\n    title       varchar(40) NOT NULL,\n    did         integer NOT NULL,\n    date_prod   date,\n    kind        varchar(10),\n    len         interval hour to minute\n)\nSERVER film_server;"
  },
  {
    "Query": "CREATE FOREIGN TABLE measurement_y2016m07\n    PARTITION OF measurement FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')\n    SERVER server_07;"
  }
]